;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;CCS:   ;mk
;	.nolist 
;	.title "msp430 eForth 4.3" 
;	.cdecls C,LIST,"msp430g2553.h"  ; Include device header file 

;naken: ;mk
    .msp430 
    .include "msp430g2553.inc"  ; MCU-specific register equates 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; 7/7/2012 430eForth1.0, from eForth86.asm and 430uForth
; 7/4/2012 Move 430uForth2.1 from IAR to CCS 5.2
; 8/5/2014 Move 430eForth2.2 to CCS 6.0.  Fix linkage of OVER.
;	Software UART at 2400 baud.
; 8/10/2014 430eForth2.3 9600 baud, thanks to Dirk Bruehl and
;	Michael Kalus of www.4e4th.org
; 8/10/2014 430eForth2.4 Restore ERASE and WRITE
; 8/20/2014 430eForth2.5 Test Segment D
; 8/25/2014 430eForth2.6 Turnkey
; 8/26/2014 430eForth2.7 Optimize
; 9/16/2014 430eForth3.1 Tail recursion, APP!
; 10/11/2014 430eForth4.1 Direct thread, more optimization
; 10/23/2014 430eForth4.2 Direct thread, pack lists
; 11/12/2014 430eForth4.2 Direct thread, final
; 05/13/2018 Move 430eForth4.3 from CSS to Michael Kohn's naken_asm (ver. 23 april 2018) - ok 

; Build for and verified on MSP430G2 LaunchPad from TI
; Assembled with Code Composer Sudio 6.0 IDE
; Internal DCO at 8 MHz
; Hardware UART at 9600 baud. TXD and RXD must be crossed.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Direct Thread Model of eForth

; CCS: .equ ; naken: equ   ;mk
;;	CPU registers
tos	equ	R4
stack   equ	R5
ip	equ	R6
temp0	equ	R7
temp1	equ	R8
temp2	equ	R9
temp3	equ	R10

;; Macros
; CCS: <name> .macro ; naken: .macro <name>   ;mk
.macro pops	;DROP
	mov.w	@stack+,tos
    .endm

.macro pushs ;DUP
	decd.w	stack
	mov.w	tos,0(stack)
    .endm;; Constants

.macro INEXT ;mk renamed INEXT to INEXT - inline code for NEXT.
	mov @ip+,pc	; fetch code address into PC
    .endm

.macro INEST ;mk renamed INEST to INEST - inline code for NEST.
	.align	16  ; CCS: 2 bytes align ; naken: 16 bit align. mk
	call	#DOLST	; fetch code address into PC, W=PFA
    .endm

.macro ICONST ;mk renamed ICONST to ICONST - inline code calling DOCON.
	.align	16  ; CCS: 2 bytes align ; naken: 16 bit align. mk
	call	#DOCON	; fetch code address into PC, W=PFA
	.endm

;; Assembler constants

COMPO	equ	040H	;lexicon compile only bit
IMEDD	equ	080H	;lexicon immediate bit
MASKK	equ	07F1FH	;lexicon bit mask
CELLL	equ	2	;size of a cell
BASEE	equ	10	;default radix
VOCSS	equ	8	;depth of vocabulary stack
BKSPP	equ	8	;backspace
LF	    equ	10	;line feed
CRR	    equ	13	;carriage return
ERR	    equ	27	;error escape
TIC	    equ	39	;tick
CALLL	equ	012B0H	;NOP CALL opcodes

UPP	    equ	200H
DPP	    equ	220H
SPP	    equ	378H	;data stack
TIBB	equ	380H	;terminal input buffer
RPP	    equ	3F8H	;return stacl
CODEE	equ	0C000H	;code dictionary
COLDD	equ	0FFFEH	;cold start vector
EM	    equ	0FFFFH	;top of memory

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	.list

;;;;
;; Main entry points and COLD start data

;	.text       ; CCS: Predefined Memory Segment Name : Main memory (flash or ROM)
    .org 0C000H ; naken : MSP430G2553 main memory : C000-FFFF = 16KB flash ROM 
                ;                                   FFE0-FFFF = interrupt vectors

;	.global	main ; CCS: File Reference Directive 
                 ; unused in naken

main: 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Device dependent I/O

;   ?KEY	( -- F | c T )
;	Return input character.
	.dw	0
	.db	4,"?KEY",0
QKEY:
	pushs

0xc008: 0x8325 sub.w #2, r5                             cycles: 1


0xc00a: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc00c: 0x0000

QKEY1:
	BIT.B   #UCA0RXIFG,&IFG2

0xc00e: 0xb3d2 bit.b #1, &0x0003                        cycles: 4
0xc010: 0x0003

	JZ	FALSE	;return false flag

0xc012: 0x24c3 jeq 0xc19a  (offset: 390)                cycles: 2

	MOV.B   &UCA0RXBUF,tos	; read character into TOS

0xc014: 0x4254 mov.b &0x0066, r4                        cycles: 3
0xc016: 0x0066

	pushs

0xc018: 0x8325 sub.w #2, r5                             cycles: 1


0xc01a: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc01c: 0x0000

	jmp	TRUE

0xc01e: 0x3cbf jmp 0xc19e  (offset: 382)                cycles: 2


;   KEY	( -- c )
;	Return input character.
	.dw	QKEY-6
	.db 3,"KEY"
KEY: ;mk naken needs colon after label. 
	pushs

0xc026: 0x8325 sub.w #2, r5                             cycles: 1


0xc028: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc02a: 0x0000

KEY1:
	BIT.B   #UCA0RXIFG,&IFG2

0xc02c: 0xb3d2 bit.b #1, &0x0003                        cycles: 4
0xc02e: 0x0003

	JZ	KEY1

0xc030: 0x27fd jeq 0xc02c  (offset: -6)                 cycles: 2

	MOV.B   &UCA0RXBUF,tos	; read character into TOS

0xc032: 0x4254 mov.b &0x0066, r4                        cycles: 3
0xc034: 0x0066

	INEXT

0xc036: 0x4630 mov.w @r6+, PC                           cycles: 3


;   EMIT	( c -- )
;	Send character c to the output device.
	.dw	KEY-4
	.db 4,"EMIT",0
EMIT:
EMIT1:
	BIT.B   #UCA0TXIFG,&IFG2

0xc040: 0xb3e2 bit.b #2, &0x0003                        cycles: 4
0xc042: 0x0003

	JZ	EMIT1

0xc044: 0x27fd jeq 0xc040  (offset: -6)                 cycles: 2

	MOV.B   tos,&UCA0TXBUF

0xc046: 0x44c2 mov.b r4, &0x0067                        cycles: 4
0xc048: 0x0067

	pops

0xc04a: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc04c: 0x4630 mov.w @r6+, PC                           cycles: 3


;   !IO	( -- )
;	Initialize the serial I/O devices.
;	.dw	EMIT-6
;	.db 3,"!IO"
STOIO:
; 8MHz
	mov.b   &CALBC1_8MHZ, &BCSCTL1   ; Set DCO

0xc04e: 0x42d2 mov.b &0x10fd, &0x0057                   cycles: 6
0xc050: 0x10fd
0xc052: 0x0057

	mov.b   &CALDCO_8MHZ, &DCOCTL	; to 8 MHz.

0xc054: 0x42d2 mov.b &0x10fc, &0x0056                   cycles: 6
0xc056: 0x10fc
0xc058: 0x0056

	mov.b   #006h, &P1SEL	; Use P1.1/P1.2 for USCI_A0

0xc05a: 0x40f2 mov.b #0x06, &0x0026                     cycles: 5
0xc05c: 0x0006
0xc05e: 0x0026

	mov.b   #006h, &P1SEL2	; Use P1.1/P1.2 for USCI_A0

0xc060: 0x40f2 mov.b #0x06, &0x0041                     cycles: 5
0xc062: 0x0006
0xc064: 0x0041

; Configure UART (Koch)
	bis.b   #UCSSEL_2,&UCA0CTL1	;db2 SMCLK

0xc066: 0xd0f2 bis.b #0x80, &0x0061                     cycles: 5
0xc068: 0x0080
0xc06a: 0x0061

	mov.b   #65,&UCA0BR0	;db3 8MHz 9600 Insgesamt &833 = $341

0xc06c: 0x40f2 mov.b #0x41, &0x0062                     cycles: 5
0xc06e: 0x0041
0xc070: 0x0062

	mov.b   #3,&UCA0BR1	;db4 8MHz 9600

0xc072: 0x40f2 mov.b #0x03, &0x0063                     cycles: 5
0xc074: 0x0003
0xc076: 0x0063

	mov.b   #UCBRS_2,&UCA0MCTL	;db5 Modulation UCBRSx = 2

0xc078: 0x42e2 mov.b #4, &0x0064                        cycles: 4
0xc07a: 0x0064

	bic.b   #UCSWRST,&UCA0CTL1	;db6 **Initialize USCI

0xc07c: 0xc3d2 bic.b #1, &0x0061                        cycles: 4
0xc07e: 0x0061

	INEXT	
0xc080: 0x4630 mov.w @r6+, PC                           cycles: 3

;called from COLD

;; The kernel

;   doLIT	( -- w )
;	Push an inline literal.
;	.dw	STOIO-4
;	.db COMPO+5,"doLIT"
DOLIT:
	pushs

0xc082: 0x8325 sub.w #2, r5                             cycles: 1


0xc084: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc086: 0x0000

	mov	@ip+,tos

0xc088: 0x4634 mov.w @r6+, r4                           cycles: 2

	INEXT

0xc08a: 0x4630 mov.w @r6+, PC                           cycles: 3


;   doCON	( -- a )
;	Run time routine for CONSTANT, VARIABLE and CREATE.
;	.dw	DOLIT-6
;	.db COMPO+5,"doCON"
DOCON:
	pushs

0xc08c: 0x8325 sub.w #2, r5                             cycles: 1


0xc08e: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc090: 0x0000

	pop	tos

0xc092: 0x4134 pop.w r4   --  mov.w @SP+, r4            cycles: 2

	mov	@tos,tos

0xc094: 0x4424 mov.w @r4, r4                            cycles: 2

	INEXT

0xc096: 0x4630 mov.w @r6+, PC                           cycles: 3


;   doLIST	( -- )
;	Process colon list..
;	.dw	EMIT-6
;	.db 6,"doLIST",0
DOLST:
	mov	ip,temp0	;exchange pointers

0xc098: 0x4607 mov.w r6, r7                             cycles: 1

	pop	ip	;push return stack

0xc09a: 0x4136 pop.w r6   --  mov.w @SP+, r6            cycles: 2

	push	temp0	;restore the pointers

0xc09c: 0x1207 push.w r7                                cycles: 3

	INEXT

0xc09e: 0x4630 mov.w @r6+, PC                           cycles: 3


;   EXIT	( -- )
;	Terminate a colon definition.
	.dw	EMIT-6
	.db 4,"EXIT",0
EXIT:
	mov	@sp+,ip

0xc0a8: 0x4136 pop.w r6   --  mov.w @SP+, r6            cycles: 2

	INEXT

0xc0aa: 0x4630 mov.w @r6+, PC                           cycles: 3


;   EXECUTE	( ca -- )
;	Execute the word at ca.
	.dw	EXIT-6
	.db 7,"EXECUTE"
EXECU:
	mov	tos,temp0

0xc0b6: 0x4407 mov.w r4, r7                             cycles: 1

	pops

0xc0b8: 0x4534 mov.w @r5+, r4                           cycles: 2

	br	temp0

0xc0ba: 0x4700 mov.w r7, PC                             cycles: 2


;   @EXECUTE	( a -- )
;	Execute vector stored in address a.
	.dw	EXECU-8
	.db 8,"@EXECUTE",0
ATEXE:
	mov	@tos,temp0

0xc0c8: 0x4427 mov.w @r4, r7                            cycles: 2

	pops

0xc0ca: 0x4534 mov.w @r5+, r4                           cycles: 2

	br	temp0

0xc0cc: 0x4700 mov.w r7, PC                             cycles: 2


;   branch	( -- )
;	Branch to an inline address.
;	.dw	ATEXE-10
;	.db COMPO+6,"branch",0
BRAN:
	mov	@ip+,ip

0xc0ce: 0x4636 mov.w @r6+, r6                           cycles: 2

	INEXT

0xc0d0: 0x4630 mov.w @r6+, PC                           cycles: 3


;   ?branch	( f -- )
;	Branch if flag is zero.
;	.dw	BRAN-8
;	.db COMPO+7,"?branch"
QBRAN:
	tst	tos

0xc0d2: 0x9304 cmp.w #0, r4                             cycles: 1

	pops

0xc0d4: 0x4534 mov.w @r5+, r4                           cycles: 2

	jz	BRAN

0xc0d6: 0x27fb jeq 0xc0ce  (offset: -10)                cycles: 2

	jmp	SKIP

0xc0d8: 0x3c04 jmp 0xc0e2  (offset: 8)                  cycles: 2


;   next	( -- )
;	Run time code for the single index loop.
;	: next ( -- ) \ hilevel model
;	r> r> dup if 1 - >r @ >r exit then drop cell+ >r ;
;	.dw	QBRAB-8
;	.db COMPO+4,"next",0
DONXT:
	dec	0(sp)   ;decrement index

0xc0da: 0x8391 sub.w #1, 0(SP)                          cycles: 4
0xc0dc: 0x0000

	jge	BRAN	;loop back

0xc0de: 0x37f7 jge 0xc0ce  (offset: -18)                cycles: 2

	incd.w	sp	;discard index

0xc0e0: 0x5321 add.w #2, SP                             cycles: 1

SKIP:
	incd.w	ip	;exit loop

0xc0e2: 0x5326 add.w #2, r6                             cycles: 1

	INEXT

0xc0e4: 0x4630 mov.w @r6+, PC                           cycles: 3


;   !	( w a -- )
;	Pop the data stack to memory.
	.dw	ATEXE-10
	.db 1,"!"
STORE:
	mov.w	@stack+,0(tos)

0xc0ea: 0x45b4 mov.w @r5+, 0(r4)                        cycles: 5
0xc0ec: 0x0000

	pops

0xc0ee: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc0f0: 0x4630 mov.w @r6+, PC                           cycles: 3


;   @	( a -- w )
;	Push memory location to the data stack.
	.dw	STORE-2
	.db 1,"@"
AT:
	mov.w	@tos,tos

0xc0f6: 0x4424 mov.w @r4, r4                            cycles: 2

	INEXT

0xc0f8: 0x4630 mov.w @r6+, PC                           cycles: 3


;   C!	( c b -- )
;	Pop the data stack to byte memory.
	.dw	AT-2
	.db 2,"C!",0
CSTOR:
	mov.b	@stack+,0(tos)

0xc100: 0x45f4 mov.b @r5+, 0(r4)                        cycles: 5
0xc102: 0x0000

	inc	stack

0xc104: 0x5315 add.w #1, r5                             cycles: 1

	pops

0xc106: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc108: 0x4630 mov.w @r6+, PC                           cycles: 3


;   C@	( b -- c )
;	Push byte memory location to the data stack.
	.dw	CSTOR-4
	.db 2,"C@",0
CAT:
	mov.b	@tos,tos

0xc110: 0x4464 mov.b @r4, r4                            cycles: 2

	INEXT

0xc112: 0x4630 mov.w @r6+, PC                           cycles: 3


;   RP!	( -- )
;	init return stack pointer.
;	.dw	CAT-4
;	.db 3,"RP!"
RPSTO:
	mov	#RPP,SP	;init return stack

0xc114: 0x4031 mov.w #0x03f8, SP                        cycles: 2
0xc116: 0x03f8

	INEXT

0xc118: 0x4630 mov.w @r6+, PC                           cycles: 3


;   R>	( -- w )
;	Pop the return stack to the data stack.
	.dw	CAT-4
	.db 2,"R",3EH,0
RFROM:
	pushs

0xc120: 0x8325 sub.w #2, r5                             cycles: 1


0xc122: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc124: 0x0000

	pop	tos

0xc126: 0x4134 pop.w r4   --  mov.w @SP+, r4            cycles: 2

	INEXT

0xc128: 0x4630 mov.w @r6+, PC                           cycles: 3


;   R@	( -- w )
;	Copy top of return stack to the data stack.
	.dw	RFROM-4
	.db 2,"R@",0
RAT:
	pushs

0xc130: 0x8325 sub.w #2, r5                             cycles: 1


0xc132: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc134: 0x0000

	mov	0(sp),tos

0xc136: 0x4114 mov.w 0(SP), r4                          cycles: 3
0xc138: 0x0000

	INEXT

0xc13a: 0x4630 mov.w @r6+, PC                           cycles: 3


;   >R	( w -- )
;	Push the data stack to the return stack.
	.dw	RAT-4
	.db COMPO+2,">R",0
TOR:
	push	tos

0xc142: 0x1204 push.w r4                                cycles: 3

	pops

0xc144: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc146: 0x4630 mov.w @r6+, PC                           cycles: 3


;   SP!	( -- )
;	Init data stack pointer.
;	.dw	SPAT-4
;	.db 3,"SP!"
SPSTO:
	mov	#SPP,stack	;init parameter stack

0xc148: 0x4035 mov.w #0x0378, r5                        cycles: 2
0xc14a: 0x0378

	clr	tos

0xc14c: 0x4304 mov.w #0, r4                             cycles: 1

	INEXT

0xc14e: 0x4630 mov.w @r6+, PC                           cycles: 3


;   DROP	( w -- )
;	Discard top stack item.
	.dw	TOR-4
	.db 4,"DROP",0
DROP:
	pops

0xc158: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc15a: 0x4630 mov.w @r6+, PC                           cycles: 3


;   DUP	( w -- w w )
;	Duplicate the top stack item.
	.dw	DROP-6
	.db 3,"DUP"
DUPP:
	pushs

0xc162: 0x8325 sub.w #2, r5                             cycles: 1


0xc164: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc166: 0x0000

	INEXT

0xc168: 0x4630 mov.w @r6+, PC                           cycles: 3


;   SWAP	( w1 w2 -- w2 w1 )
;	Exchange top two stack items.
	.dw	DUPP-4
	.db 4,"SWAP",0
SWAP:
	mov.w	tos,temp0

0xc172: 0x4407 mov.w r4, r7                             cycles: 1

	mov.w	@stack,tos

0xc174: 0x4524 mov.w @r5, r4                            cycles: 2

	mov.w	temp0,0(stack)

0xc176: 0x4785 mov.w r7, 0(r5)                          cycles: 4
0xc178: 0x0000

	INEXT

0xc17a: 0x4630 mov.w @r6+, PC                           cycles: 3


;   OVER	( w1 w2 -- w1 w2 w1 )
;	Copy second stack item to top.
	.dw	SWAP-6
	.db 4,"OVER",0
OVER:
	mov.w	@stack,temp0

0xc184: 0x4527 mov.w @r5, r7                            cycles: 2

	pushs

0xc186: 0x8325 sub.w #2, r5                             cycles: 1


0xc188: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc18a: 0x0000

	mov.w	temp0,tos

0xc18c: 0x4704 mov.w r7, r4                             cycles: 1

	INEXT

0xc18e: 0x4630 mov.w @r6+, PC                           cycles: 3


;   0<	( n -- t )
;	Return true if n is negative.
	.dw	OVER-6
	.db 2,"0",3CH,0
ZLESS:
	tst	tos

0xc196: 0x9304 cmp.w #0, r4                             cycles: 1

	jn	TRUE

0xc198: 0x3002 jn 0xc19e  (offset: 4)                   cycles: 2

FALSE:
	clr	tos

0xc19a: 0x4304 mov.w #0, r4                             cycles: 1

	INEXT

0xc19c: 0x4630 mov.w @r6+, PC                           cycles: 3

TRUE:
	mov	#0x-1,tos

0xc19e: 0x4334 mov.w #-1, r4                            cycles: 1

	INEXT

0xc1a0: 0x4630 mov.w @r6+, PC                           cycles: 3


;   AND	( w w -- w )
;	Bitwise AND.
	.dw	ZLESS-4
	.db 3,"AND"
ANDD:
	and	@stack+,tos

0xc1a8: 0xf534 and.w @r5+, r4                           cycles: 2

	INEXT

0xc1aa: 0x4630 mov.w @r6+, PC                           cycles: 3


;   OR	( w w -- w )
;	Bitwise inclusive OR.
	.dw	ANDD-4
	.db 2,"OR",0
ORR:
	bis	@stack+,tos

0xc1b2: 0xd534 bis.w @r5+, r4                           cycles: 2

	INEXT

0xc1b4: 0x4630 mov.w @r6+, PC                           cycles: 3


;   XOR	( w w -- w )
;	Bitwise exclusive OR.
	.dw	ORR-4
	.db 3,"XOR"
XORR:
	xor	@stack+,tos

0xc1bc: 0xe534 xor.w @r5+, r4                           cycles: 2

	INEXT

0xc1be: 0x4630 mov.w @r6+, PC                           cycles: 3


;   UM+	( w w -- w cy )
;	Add two numbers, return the sum and carry flag.
	.dw	XORR-4
	.db 3,"UM+"
UPLUS:
	add	@stack,tos

0xc1c6: 0x5524 add.w @r5, r4                            cycles: 2

	mov	tos,0(stack)

0xc1c8: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc1ca: 0x0000

	clr	tos

0xc1cc: 0x4304 mov.w #0, r4                             cycles: 1

	rlc	tos

0xc1ce: 0x6404 addc.w r4, r4                            cycles: 1

	INEXT

0xc1d0: 0x4630 mov.w @r6+, PC                           cycles: 3


;; Common functions

;   ?DUP	( w -- w w | 0 )
;	Dup tos if its is not zero.
	.dw	UPLUS-4
	.db 4,"?DUP",0
QDUP:
	tst	tos

0xc1da: 0x9304 cmp.w #0, r4                             cycles: 1

	jnz	DUPP

0xc1dc: 0x23c2 jne 0xc162  (offset: -124)               cycles: 2

	INEXT

0xc1de: 0x4630 mov.w @r6+, PC                           cycles: 3


;   ROT	( w1 w2 w3 -- w2 w3 w1 )
;	Rot 3rd item to top.
	.dw	QDUP-6
	.db 3,"ROT"
ROT:
	mov.w	0(stack),temp0

0xc1e6: 0x4517 mov.w 0(r5), r7                          cycles: 3
0xc1e8: 0x0000

	mov.w	tos,0(stack)

0xc1ea: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc1ec: 0x0000

	mov.w	2(stack),tos

0xc1ee: 0x4514 mov.w 2(r5), r4                          cycles: 3
0xc1f0: 0x0002

	mov.w	temp0,2(stack)

0xc1f2: 0x4785 mov.w r7, 2(r5)                          cycles: 4
0xc1f4: 0x0002

	INEXT

0xc1f6: 0x4630 mov.w @r6+, PC                           cycles: 3


;   2DROP	( w w -- )
;	Discard two items on stack.
	.dw	ROT-4
	.db 5,"2DROP"
DDROP:
	incd.w	stack

0xc200: 0x5325 add.w #2, r5                             cycles: 1

	pops

0xc202: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc204: 0x4630 mov.w @r6+, PC                           cycles: 3


;   2DUP	( w1 w2 -- w1 w2 w1 w2 )
;	Duplicate top two items.
	.dw	DDROP-6
	.db 4,"2DUP",0
DDUP:
	mov.w	@stack,temp0

0xc20e: 0x4527 mov.w @r5, r7                            cycles: 2

	pushs

0xc210: 0x8325 sub.w #2, r5                             cycles: 1


0xc212: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc214: 0x0000

	decd.w	stack

0xc216: 0x8325 sub.w #2, r5                             cycles: 1

	mov.w	temp0,0(stack)

0xc218: 0x4785 mov.w r7, 0(r5)                          cycles: 4
0xc21a: 0x0000

	INEXT

0xc21c: 0x4630 mov.w @r6+, PC                           cycles: 3


;   +	( w w -- sum )
;	Add top two items.
	.dw	DDUP-6
	.db 1,"+"
PLUS:
	add	@stack+,tos

0xc222: 0x5534 add.w @r5+, r4                           cycles: 2

	INEXT

0xc224: 0x4630 mov.w @r6+, PC                           cycles: 3


;   D+	( d d -- d )
;	Double addition, as an example using UM+.
;
	.dw	PLUS-2
	.db 2,"D+",0
DPLUS:
	mov.w	@stack+,temp0

0xc22c: 0x4537 mov.w @r5+, r7                           cycles: 2

	mov.w	@stack+,temp1

0xc22e: 0x4538 mov.w @r5+, r8                           cycles: 2

	add.w	temp0,0(stack)

0xc230: 0x5785 add.w r7, 0(r5)                          cycles: 4
0xc232: 0x0000

	addc	temp1,tos

0xc234: 0x6804 addc.w r8, r4                            cycles: 1

	INEXT

0xc236: 0x4630 mov.w @r6+, PC                           cycles: 3


;   NOT	( w -- w )
;	One's complement of tos.
	.dw	DPLUS-4
	.db 3,"NOT"
INVER:
	inv	tos

0xc23e: 0xe334 xor.w #-1, r4                            cycles: 1

	INEXT

0xc240: 0x4630 mov.w @r6+, PC                           cycles: 3


;   NEGATE	( n -- -n )
;	Two's complement of tos.
	.dw	INVER-4
	.db 6,"NEGATE",0
NEGAT:
	inv	tos

0xc24c: 0xe334 xor.w #-1, r4                            cycles: 1

	inc	tos

0xc24e: 0x5314 add.w #1, r4                             cycles: 1

	INEXT

0xc250: 0x4630 mov.w @r6+, PC                           cycles: 3


;   DNEGATE	( d -- -d )
;	Two's complement of top double.
	.dw	NEGAT-8
	.db 7,"DNEGATE"
DNEGA:
	inv	tos

0xc25c: 0xe334 xor.w #-1, r4                            cycles: 1

	inv 0(stack)

0xc25e: 0xe3b5 xor.w #-1, 0(r5)                         cycles: 4
0xc260: 0x0000

	inc	0(stack)

0xc262: 0x5395 add.w #1, 0(r5)                          cycles: 4
0xc264: 0x0000

	addc	#0,tos

0xc266: 0x6304 addc.w #0, r4                            cycles: 1

	INEXT

0xc268: 0x4630 mov.w @r6+, PC                           cycles: 3


;   -	( n1 n2 -- n1-n2 )
;	Subtraction.
	.dw	DNEGA-8
	.db 1,"-"
SUBB:
	sub	@stack+,tos

0xc26e: 0x8534 sub.w @r5+, r4                           cycles: 2

	jmp	NEGAT

0xc270: 0x3fed jmp 0xc24c  (offset: -38)                cycles: 2


;   ABS	( n -- n )
;	Return the absolute value of n.
	.dw	SUBB-2
	.db 3,"ABS"
ABSS:
	tst.w	tos

0xc278: 0x9304 cmp.w #0, r4                             cycles: 1

	jn	NEGAT

0xc27a: 0x33e8 jn 0xc24c  (offset: -48)                 cycles: 2

	INEXT

0xc27c: 0x4630 mov.w @r6+, PC                           cycles: 3


;   =	( w w -- t )
;	Return true if top two are equal.
	.dw	ABSS-4
	.db 1,3DH
EQUAL:
	xor	@stack+,tos

0xc282: 0xe534 xor.w @r5+, r4                           cycles: 2

	jnz	FALSE

0xc284: 0x238a jne 0xc19a  (offset: -236)               cycles: 2

	jmp	TRUE

0xc286: 0x3f8b jmp 0xc19e  (offset: -234)               cycles: 2


;   U<	( u u -- t )
;	Unsigned compare of top two items.
	.dw	EQUAL-2
	.db 2,"U",3CH,0
ULESS:
	mov	@stack+,temp0

0xc28e: 0x4537 mov.w @r5+, r7                           cycles: 2

	cmp	tos,temp0

0xc290: 0x9407 cmp.w r4, r7                             cycles: 1

	subc	tos,tos

0xc292: 0x7404 subc.w r4, r4                            cycles: 1

	INEXT

0xc294: 0x4630 mov.w @r6+, PC                           cycles: 3


;   <	( n1 n2 -- t )
;	Signed compare of top two items.
	.dw	ULESS-4
	.db 1,3CH
LESS:
	cmp	@stack+,tos

0xc29a: 0x9534 cmp.w @r5+, r4                           cycles: 2

	jz	FALSE

0xc29c: 0x277e jeq 0xc19a  (offset: -260)               cycles: 2

	jge	TRUE

0xc29e: 0x377f jge 0xc19e  (offset: -258)               cycles: 2

	jmp	FALSE

0xc2a0: 0x3f7c jmp 0xc19a  (offset: -264)               cycles: 2


;   >	( n1 n2 -- t )
;	Signed compare of top two items.
	.dw	LESS-2
	.db 1,3EH
GREAT:
	cmp	@stack+,tos

0xc2a6: 0x9534 cmp.w @r5+, r4                           cycles: 2

	jge	FALSE

0xc2a8: 0x3778 jge 0xc19a  (offset: -272)               cycles: 2

	jmp	TRUE

0xc2aa: 0x3f79 jmp 0xc19e  (offset: -270)               cycles: 2


;   MAX	( n n -- n )
;	Return the greater of two top stack items.
	.dw	GREAT-2
	.db 3,"MAX"
MAX:
	cmp	0(stack),tos

0xc2b2: 0x9514 cmp.w 0(r5), r4                          cycles: 3
0xc2b4: 0x0000

MAX1:
	jl	DROP

0xc2b6: 0x3b50 jl 0xc158  (offset: -352)                cycles: 2

	incd.w	stack

0xc2b8: 0x5325 add.w #2, r5                             cycles: 1

	INEXT

0xc2ba: 0x4630 mov.w @r6+, PC                           cycles: 3


;   MIN	( n n -- n )
;	Return the smaller of top two stack items.
	.dw	MAX-4
	.db 3,"MIN"
MIN:
	cmp	tos,0(stack)

0xc2c2: 0x9485 cmp.w r4, 0(r5)                          cycles: 4
0xc2c4: 0x0000

	jmp	MAX1

0xc2c6: 0x3ff7 jmp 0xc2b6  (offset: -18)                cycles: 2


;; Divide

;   UM/MOD	( udl udh u -- ur uq )
;	Unsigned divide of a double by a single. Return mod and quotient.
	.dw	MIN-4
	.db 6,"UM/MOD",0
UMMOD:
	mov	tos,temp0

0xc2d2: 0x4407 mov.w r4, r7                             cycles: 1

	pops

0xc2d4: 0x4534 mov.w @r5+, r4                           cycles: 2

	mov	#17,temp1

0xc2d6: 0x4038 mov.w #0x0011, r8                        cycles: 2
0xc2d8: 0x0011

UMMOD2:
	cmp	temp0,tos

0xc2da: 0x9704 cmp.w r7, r4                             cycles: 1

	jnc	UMMOD3

0xc2dc: 0x2803 jlo 0xc2e4  (offset: 6)                  cycles: 2

	sub	temp0,tos

0xc2de: 0x8704 sub.w r7, r4                             cycles: 1

	setc

0xc2e0: 0xd312 setc  --  bis.w #1, SR                   cycles: 1

	jmp	UMMOD4

0xc2e2: 0x3c01 jmp 0xc2e6  (offset: 2)                  cycles: 2

UMMOD3:
	clrc

0xc2e4: 0xc312 clrc  --  bic.w #1, SR                   cycles: 1

UMMOD4:
	rlc	0(stack)

0xc2e6: 0x6595 addc.w 0(r5), 0(r5)                      cycles: 6
0xc2e8: 0x0000
0xc2ea: 0x0000

	rlc	tos

0xc2ec: 0x6404 addc.w r4, r4                            cycles: 1

	dec	temp1

0xc2ee: 0x8318 sub.w #1, r8                             cycles: 1

	jnz	UMMOD2

0xc2f0: 0x23f4 jne 0xc2da  (offset: -24)                cycles: 2

	rra	tos

0xc2f2: 0x1104 rra.w r4                                 cycles: 1

	mov	tos,temp0

0xc2f4: 0x4407 mov.w r4, r7                             cycles: 1

	mov	0(stack),tos

0xc2f6: 0x4514 mov.w 0(r5), r4                          cycles: 3
0xc2f8: 0x0000

	mov	temp0,0(stack)

0xc2fa: 0x4785 mov.w r7, 0(r5)                          cycles: 4
0xc2fc: 0x0000

	INEXT

0xc2fe: 0x4630 mov.w @r6+, PC                           cycles: 3


;   M/MOD	( d n -- r q )
;	Signed floored divide of double by single. Return mod and quotient.
	.dw	UMMOD-8
	.db 5,"M/MOD"
MSMOD:
	INEST

0xc308: 0x12b0 call #0xc098                             cycles: 5
0xc30a: 0xc098

	.dw	DUPP,ZLESS,DUPP,TOR,QBRAN,MMOD1
	.dw	NEGAT,TOR,DNEGA,RFROM
MMOD1:
	.dw	TOR,DUPP,ZLESS,QBRAN,MMOD2
	.dw	RAT,PLUS
MMOD2:
	.dw	RFROM,UMMOD,RFROM,QBRAN,MMOD3
	.dw	SWAP,NEGAT,SWAP
MMOD3:
	.dw	EXIT

;   /MOD	( n n -- r q )
;	Signed divide. Return mod and quotient.
	.dw	MSMOD-6
	.db 4,"/MOD",0
SLMOD:
	INEST

0xc348: 0x12b0 call #0xc098                             cycles: 5
0xc34a: 0xc098

	.dw	OVER,ZLESS,SWAP,MSMOD,EXIT

;   MOD	( n n -- r )
;	Signed divide. Return mod only.
	.dw	SLMOD-6
	.db 3,"MOD"
MODD:
	INEST

0xc35c: 0x12b0 call #0xc098                             cycles: 5
0xc35e: 0xc098

	.dw	SLMOD,DROP,EXIT

;   /	( n n -- q )
;	Signed divide. Return quotient only.
	.dw	MODD-4
	.db 1,"/"
SLASH:
	INEST

0xc36a: 0x12b0 call #0xc098                             cycles: 5
0xc36c: 0xc098

	.dw	SLMOD,SWAP,DROP,EXIT

;; Multiply

;   UM*	( u u -- ud )
;	Unsigned multiply. Return double product.
	.dw	SLASH-2
	.db 3,"UM*"
UMSTA:
	clr	temp0

0xc37c: 0x4307 mov.w #0, r7                             cycles: 1

	mov	#16,temp1

0xc37e: 0x4038 mov.w #0x0010, r8                        cycles: 2
0xc380: 0x0010

UMSTA2:
	bit	#1,0(stack)

0xc382: 0xb395 bit.w #1, 0(r5)                          cycles: 4
0xc384: 0x0000

	jz	UMSTA3

0xc386: 0x2402 jeq 0xc38c  (offset: 4)                  cycles: 2

	add	tos,temp0

0xc388: 0x5407 add.w r4, r7                             cycles: 1

	jmp	UMSTA4

0xc38a: 0x3c01 jmp 0xc38e  (offset: 2)                  cycles: 2

UMSTA3:
	clrc

0xc38c: 0xc312 clrc  --  bic.w #1, SR                   cycles: 1

UMSTA4:
	rrc	temp0

0xc38e: 0x1007 rrc.w r7                                 cycles: 1

	rrc	0(stack)

0xc390: 0x1015 rrc.w 0(r5)                              cycles: 4
0xc392: 0x0000

	dec	temp1

0xc394: 0x8318 sub.w #1, r8                             cycles: 1

	jnz	UMSTA2

0xc396: 0x23f5 jne 0xc382  (offset: -22)                cycles: 2

	mov	temp0,tos

0xc398: 0x4704 mov.w r7, r4                             cycles: 1

	INEXT

0xc39a: 0x4630 mov.w @r6+, PC                           cycles: 3


;   *	( n n -- n )
;	Signed multiply. Return single product.
	.dw	UMSTA-4
	.db 1,"*"
STAR:
	INEST

0xc3a0: 0x12b0 call #0xc098                             cycles: 5
0xc3a2: 0xc098

	.dw	UMSTA,DROP,EXIT

;   M*	( n n -- d )
;	Signed multiply. Return double product.
	.dw	STAR-2
	.db 2,"M*",0
MSTAR:
	INEST

0xc3b0: 0x12b0 call #0xc098                             cycles: 5
0xc3b2: 0xc098

	.dw	DDUP,XORR,ZLESS,TOR
	.dw	ABSS,SWAP,ABSS,UMSTA,RFROM
	.dw	QBRAN,MSTA1
	.dw	DNEGA
MSTA1:
	.dw	EXIT

;   */MOD	( n1 n2 n3 -- r q )
;	Multiply n1 and n2, then divide by n3. Return mod and quotient.
	.dw	MSTAR-4
	.db 5,"*/MOD"
SSMOD:
	INEST

0xc3d6: 0x12b0 call #0xc098                             cycles: 5
0xc3d8: 0xc098

	.dw	TOR,MSTAR,RFROM,MSMOD,EXIT

;   */	( n1 n2 n3 -- q )
;	Multiply n1 by n2, then divide by n3. Return quotient only.
	.dw	SSMOD-6
	.db 2,"*/",0
STASL:
	INEST

0xc3ea: 0x12b0 call #0xc098                             cycles: 5
0xc3ec: 0xc098

	.dw	SSMOD,SWAP,DROP,EXIT

;; Miscellaneous

;   1+	( a -- a+1 )
;	Increment.
;	.dw	STASL-4
;	.db 2,"1+",0
ONEP:
	add	#1,tos

0xc3f6: 0x5314 add.w #1, r4                             cycles: 1

	INEXT

0xc3f8: 0x4630 mov.w @r6+, PC                           cycles: 3


;   1-	( a -- a-1 )
;	Decrement
;	.dw	ONEP-4
;	.db 2,"1-",0
ONEM:
	sub	#1,tos

0xc3fa: 0x8314 sub.w #1, r4                             cycles: 1

	INEXT

0xc3fc: 0x4630 mov.w @r6+, PC                           cycles: 3


;   2+	( a -- a+2 )
;	Add cell size in byte to address.
;	.dw	ONEM-4
;	.db 2,"2+",0
CELLP:
	add	#2,tos

0xc3fe: 0x5324 add.w #2, r4                             cycles: 1

	INEXT

0xc400: 0x4630 mov.w @r6+, PC                           cycles: 3


;   2-	( a -- a-2 )
;	Subtract cell size in byte from address.
;	.dw	CELLP-4
;	.db 2,"2-",0
CELLM:
	sub	#2,tos

0xc402: 0x8324 sub.w #2, r4                             cycles: 1

	INEXT

0xc404: 0x4630 mov.w @r6+, PC                           cycles: 3


;   2*	( n -- 2*n )
;	Multiply tos by cell size in bytes.
	.dw	STASL-4
	.db 2,"2*",0
CELLS:
	rla	tos

0xc40c: 0x5404 add.w r4, r4                             cycles: 1

	INEXT

0xc40e: 0x4630 mov.w @r6+, PC                           cycles: 3


;   2/	( n -- n/2 )
;	Divide tos by cell size in bytes.
	.dw	CELLS-4
	.db 2,"2/",0
TWOSL:
	rra	tos

0xc416: 0x1104 rra.w r4                                 cycles: 1

	INEXT

0xc418: 0x4630 mov.w @r6+, PC                           cycles: 3


;   ALIGNED	( b -- a )
;	Align address to the cell boundary.
;	.dw	TWOSL-4
;	.db 7,"ALIGNED"
ALGND:
	add	#1,tos

0xc41a: 0x5314 add.w #1, r4                             cycles: 1

	bic	#1,tos

0xc41c: 0xc314 bic.w #1, r4                             cycles: 1

	INEXT

0xc41e: 0x4630 mov.w @r6+, PC                           cycles: 3


;   >CHAR	( c -- c )
;	Filter non-printing characters.
;	.dw	TWOSL-4
;	.db 5,">CHAR"
TCHAR:
	INEST

0xc420: 0x12b0 call #0xc098                             cycles: 5
0xc422: 0xc098

	.dw	BLANK,MAX	;mask msb
	.dw	DOLIT,126,MIN	;check for printable
	.dw	EXIT

;   DEPTH	( -- n )
;	Return the depth of the data stack.
	.dw	TWOSL-4
	.db 5,"DEPTH"
DEPTH:
	mov	stack,temp0

0xc438: 0x4507 mov.w r5, r7                             cycles: 1

	pushs

0xc43a: 0x8325 sub.w #2, r5                             cycles: 1


0xc43c: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc43e: 0x0000

	mov	#SPP,tos

0xc440: 0x4034 mov.w #0x0378, r4                        cycles: 2
0xc442: 0x0378

	sub	temp0,tos

0xc444: 0x8704 sub.w r7, r4                             cycles: 1

	rra	tos

0xc446: 0x1104 rra.w r4                                 cycles: 1

	INEXT

0xc448: 0x4630 mov.w @r6+, PC                           cycles: 3


;   PICK	( ... +n -- ... w )
;	Copy the nth stack item to tos.
	.dw	DEPTH-6
	.db 4,"PICK",0
PICK:
	rla	tos

0xc452: 0x5404 add.w r4, r4                             cycles: 1

	add stack,tos

0xc454: 0x5504 add.w r5, r4                             cycles: 1

	mov	@tos,tos

0xc456: 0x4424 mov.w @r4, r4                            cycles: 2

	INEXT

0xc458: 0x4630 mov.w @r6+, PC                           cycles: 3


;; Memory access

;   +!	( n a -- )
;	Add n to the contents at address a.
	.dw	PICK-6
	.db 2,"+!",0
PSTOR:
	add @stack+,0(tos)

0xc460: 0x55b4 add.w @r5+, 0(r4)                        cycles: 5
0xc462: 0x0000

	pops

0xc464: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xc466: 0x4630 mov.w @r6+, PC                           cycles: 3


;   COUNT	( b -- b +n )
;	Return count byte of a string and add 1 to byte address.
	.dw	PSTOR-4
	.db 5,"COUNT"
COUNT:
	mov.b	@tos+,temp0

0xc470: 0x4477 mov.b @r4+, r7                           cycles: 2

	pushs

0xc472: 0x8325 sub.w #2, r5                             cycles: 1


0xc474: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc476: 0x0000

	mov	temp0,tos

0xc478: 0x4704 mov.w r7, r4                             cycles: 1

	INEXT

0xc47a: 0x4630 mov.w @r6+, PC                           cycles: 3


;   CMOVE	( b1 b2 u -- )
;	Copy u bytes from b1 to b2.
	.dw	COUNT-6
	.db 5,"CMOVE"
CMOVE:
	mov	@stack+,temp0	;destination

0xc484: 0x4537 mov.w @r5+, r7                           cycles: 2

	mov	@stack+,temp1	;source

0xc486: 0x4538 mov.w @r5+, r8                           cycles: 2

	jmp	CMOVE2

0xc488: 0x3c03 jmp 0xc490  (offset: 6)                  cycles: 2

CMOVE1:
	mov.b	@temp1+,0(temp0)

0xc48a: 0x48f7 mov.b @r8+, 0(r7)                        cycles: 5
0xc48c: 0x0000

	inc	temp0

0xc48e: 0x5317 add.w #1, r7                             cycles: 1

CMOVE2:
	dec	tos

0xc490: 0x8314 sub.w #1, r4                             cycles: 1

	jn	CMOVE3	;I need a jp.  Oh, well.

0xc492: 0x3001 jn 0xc496  (offset: 2)                   cycles: 2

	jmp	CMOVE1

0xc494: 0x3ffa jmp 0xc48a  (offset: -12)                cycles: 2

CMOVE3:
	JMP	DROP

0xc496: 0x3e60 jmp 0xc158  (offset: -832)               cycles: 2


;   FILL	( b u c -- )
;	Fill u bytes of character c to area beginning at b.
	.dw	CMOVE-6
	.db 4,"FILL",0
FILL:
	mov	@stack+,temp0	;count

0xc4a0: 0x4537 mov.w @r5+, r7                           cycles: 2

	mov	@stack+,temp1	;destination

0xc4a2: 0x4538 mov.w @r5+, r8                           cycles: 2

	jmp	FIL2

0xc4a4: 0x3c03 jmp 0xc4ac  (offset: 6)                  cycles: 2

FIL1:
	mov.b	tos,0(temp1)

0xc4a6: 0x44c8 mov.b r4, 0(r8)                          cycles: 4
0xc4a8: 0x0000

	inc	temp1

0xc4aa: 0x5318 add.w #1, r8                             cycles: 1

FIL2:
	dec	temp0

0xc4ac: 0x8317 sub.w #1, r7                             cycles: 1

	jn	FIL3

0xc4ae: 0x3001 jn 0xc4b2  (offset: 2)                   cycles: 2

	jmp	FIL1

0xc4b0: 0x3ffa jmp 0xc4a6  (offset: -12)                cycles: 2

FIL3:
	JMP	DROP

0xc4b2: 0x3e52 jmp 0xc158  (offset: -860)               cycles: 2


;; User variables

;   'BOOT	( -- a )
;	The application startup vector.
	.dw	FILL-6
	.db 5,"'BOOT"
TBOOT:
	ICONST

0xc4bc: 0x12b0 call #0xc08c                             cycles: 5
0xc4be: 0xc08c

	.dw	200H

;   BASE	( -- a )
;	Storage of the radix base for numeric I/O.
	.dw	TBOOT-6
	.db 4,"BASE",0
BASE:
	ICONST

0xc4ca: 0x12b0 call #0xc08c                             cycles: 5
0xc4cc: 0xc08c

	.dw	202H

;   tmp	( -- a )
;	A temporary storage location used in parse and find.
;	.dw	BASE-6
;	.db COMPO+3,"tmp"
TEMP:
	ICONST

0xc4d0: 0x12b0 call #0xc08c                             cycles: 5
0xc4d2: 0xc08c

	.dw	204H

;   #TIB	( -- a )
;	Hold the character pointer while parsing input stream.
;	.dw	BASE-6
;	.db 4,"#TIB",0
NTIB:
	ICONST

0xc4d6: 0x12b0 call #0xc08c                             cycles: 5
0xc4d8: 0xc08c

	.dw	206H

;   >IN	( -- a )
;	Hold the character pointer while parsing input stream.
;	.dw	NTIB-6
;	.db 3,">IN"
INN:
	ICONST

0xc4dc: 0x12b0 call #0xc08c                             cycles: 5
0xc4de: 0xc08c

	.dw	208H

;   HLD	( -- a )
;	Hold a pointer in building a numeric output string.
;	.dw	INN-4
;	.db 3,"HLD"
HLD:
	ICONST

0xc4e2: 0x12b0 call #0xc08c                             cycles: 5
0xc4e4: 0xc08c

	.dw	20AH

;   'EVAL	( -- a )
;	A area to specify vocabulary search order.
;	.dw	HLD-4
;	.db 5,"'EVAL"
TEVAL:
	ICONST

0xc4e8: 0x12b0 call #0xc08c                             cycles: 5
0xc4ea: 0xc08c

	.dw	20CH

;   CONTEXT	( -- a )
;	A area to specify vocabulary search order.
;	.dw	TEVAL-6
;	.db 7,"CONTEXT"
CNTXT:
	ICONST

0xc4ee: 0x12b0 call #0xc08c                             cycles: 5
0xc4f0: 0xc08c

	.dw	20EH

;   CP	( -- a )
;	Point to the top of the code dictionary.
	.dw	BASE-6
	.db 2,"CP",0
CP:
	ICONST

0xc4fa: 0x12b0 call #0xc08c                             cycles: 5
0xc4fc: 0xc08c

	.dw	210H

;   DP	( -- a )
;	Point to the bottom of the free ram area.
	.dw	CP-4
	.db 2,"DP",0
DP:
	ICONST

0xc506: 0x12b0 call #0xc08c                             cycles: 5
0xc508: 0xc08c

	.dw	212H

;   LAST	( -- a )
;	Point to the last name in the name dictionary.
;	.dw	DP-4
;	.db 4,"LAST",0
LAST:
	ICONST

0xc50c: 0x12b0 call #0xc08c                             cycles: 5
0xc50e: 0xc08c

	.dw	214H

;   HERE	( -- a )
;	Return the top of the code dictionary.
	.dw	DP-4
	.db 4,"HERE",0
HERE:
	INEST

0xc51a: 0x12b0 call #0xc098                             cycles: 5
0xc51c: 0xc098

	.dw	DP,AT,EXIT

;   PAD	( -- a )
;	Return the address of a temporary buffer.
	.dw	HERE-6
	.db 3,"PAD"
PAD:
	INEST

0xc52a: 0x12b0 call #0xc098                             cycles: 5
0xc52c: 0xc098

	.dw	HERE,DOLIT,80,PLUS,EXIT

;   TIB	( -- a )
;	Return the address of the terminal input buffer.
	.dw	PAD-4
	.db 3,"TIB"
TIB:
	ICONST

0xc53e: 0x12b0 call #0xc08c                             cycles: 5
0xc540: 0xc08c

	.dw	TIBB

;; Numeric output, single precision

;   DIGIT	( u -- c )
;	Convert digit u to a character.
;	.dw	LAST-6
;	.db 5,"DIGIT"
DIGIT:
	cmp	#10,tos

0xc544: 0x9034 cmp.w #0x000a, r4                        cycles: 2
0xc546: 0x000a

	jl	DIGIT1

0xc548: 0x3802 jl 0xc54e  (offset: 4)                   cycles: 2

	add	#7,tos

0xc54a: 0x5034 add.w #0x0007, r4                        cycles: 2
0xc54c: 0x0007

DIGIT1:
	add	#"0",tos

0xc54e: 0x5034 add.w #0x0030, r4                        cycles: 2
0xc550: 0x0030

	INEXT

0xc552: 0x4630 mov.w @r6+, PC                           cycles: 3


;   EXTRACT	( n base -- n c )
;	Extract the least significant digit from n.
;	.dw	DIGIT-6
;	.db 7,"EXTRACT"
EXTRC:
	INEST

0xc554: 0x12b0 call #0xc098                             cycles: 5
0xc556: 0xc098

	.dw	DOLIT,0,SWAP,UMMOD
	.dw	SWAP,DIGIT,EXIT

;   <#	( -- )
;	Initiate the numeric output process.
	.dw	TIB-4
	.db 2,"<#",0
BDIGS:
	INEST

0xc56c: 0x12b0 call #0xc098                             cycles: 5
0xc56e: 0xc098

	.dw	PAD,HLD,STORE,EXIT

;   HOLD	( c -- )
;	Insert a character into the numeric output string.
	.dw	BDIGS-4
	.db 4,"HOLD",0
HOLD:
	INEST

0xc580: 0x12b0 call #0xc098                             cycles: 5
0xc582: 0xc098

	.dw	HLD,AT,ONEM
	.dw	DUPP,HLD,STORE,CSTOR,EXIT

;   #	( u -- u )
;	Extract one digit from u and append the digit to output string.
	.dw	HOLD-6
	.db 1,"#"
DIG:
	INEST

0xc598: 0x12b0 call #0xc098                             cycles: 5
0xc59a: 0xc098

	.dw	BASE,AT,EXTRC,HOLD,EXIT

;   #S	( u -- 0 )
;	Convert u until all digits are added to the output string.
	.dw	DIG-2
	.db 2,"#S",0
DIGS:
	INEST

0xc5ac: 0x12b0 call #0xc098                             cycles: 5
0xc5ae: 0xc098

DIGS1:
	.dw	DIG,DUPP,QBRAN,DIGS2
	.dw	BRAN,DIGS1
DIGS2:
	.dw	EXIT

;   SIGN	( n -- )
;	Add a minus sign to the numeric output string.
	.dw	DIGS-4
	.db 4,"SIGN",0
SIGN:
	INEST

0xc5c6: 0x12b0 call #0xc098                             cycles: 5
0xc5c8: 0xc098

	.dw	ZLESS,QBRAN,SIGN1
	.dw	DOLIT,"-",HOLD
SIGN1:
	.dw	EXIT

;   #>	( w -- b u )
;	Prepare the output string to be TYPE'd.
	.dw	SIGN-6
	.db 2,"#",3EH,0
EDIGS:
	INEST

0xc5de: 0x12b0 call #0xc098                             cycles: 5
0xc5e0: 0xc098

	.dw	DROP,HLD,AT
	.dw	PAD,OVER,SUBB,EXIT

;   str	( n -- b u )
;	Convert a signed integer to a numeric string.
;	.dw	EDIGS-4
;	.db 3,"str"
STR:
	INEST

0xc5f0: 0x12b0 call #0xc098                             cycles: 5
0xc5f2: 0xc098

	.dw	DUPP,TOR,ABSS
	.dw	BDIGS,DIGS,RFROM
	.dw	SIGN,EDIGS,EXIT

;   HEX	( -- )
;	Use radix 16 as base for numeric conversions.
	.dw	EDIGS-4
	.db 3,"HEX"
HEX:
	mov	#16,&0x202

0xc60c: 0x40b2 mov.w #0x0010, &0x0202                   cycles: 5
0xc60e: 0x0010
0xc610: 0x0202

	INEXT

0xc612: 0x4630 mov.w @r6+, PC                           cycles: 3


;   DECIMAL	( -- )
;	Use radix 10 as base for numeric conversions.
	.dw	HEX-4
	.db 7,"DECIMAL"
DECIM:
	mov	#10,&0x202

0xc61e: 0x40b2 mov.w #0x000a, &0x0202                   cycles: 5
0xc620: 0x000a
0xc622: 0x0202

	INEXT

0xc624: 0x4630 mov.w @r6+, PC                           cycles: 3


;; Numeric input, single precision

;   DIGIT?	( c base -- u t )
;	Convert a character to its numeric value. A flag indicates success.
;	.dw	DECIM-8
;	.db 6,"DIGIT?",0
DIGTQ:
	mov	@stack,temp0

0xc626: 0x4527 mov.w @r5, r7                            cycles: 2

	sub	#"0",temp0

0xc628: 0x8037 sub.w #0x0030, r7                        cycles: 2
0xc62a: 0x0030

	jl	FALSE1

0xc62c: 0x3809 jl 0xc640  (offset: 18)                  cycles: 2

	cmp	#10,temp0

0xc62e: 0x9037 cmp.w #0x000a, r7                        cycles: 2
0xc630: 0x000a

	jl	DIGTQ1

0xc632: 0x3802 jl 0xc638  (offset: 4)                   cycles: 2

	sub	#7,temp0

0xc634: 0x8037 sub.w #0x0007, r7                        cycles: 2
0xc636: 0x0007

DIGTQ1:
	cmp	tos,temp0

0xc638: 0x9407 cmp.w r4, r7                             cycles: 1

	mov	temp0,0(stack)

0xc63a: 0x4785 mov.w r7, 0(r5)                          cycles: 4
0xc63c: 0x0000

	jl	TRUE1

0xc63e: 0x3802 jl 0xc644  (offset: 4)                   cycles: 2

FALSE1:
	clr	tos

0xc640: 0x4304 mov.w #0, r4                             cycles: 1

	INEXT

0xc642: 0x4630 mov.w @r6+, PC                           cycles: 3

TRUE1:
	mov	#-1,tos

0xc644: 0x4334 mov.w #-1, r4                            cycles: 1

	INEXT

0xc646: 0x4630 mov.w @r6+, PC                           cycles: 3


;   NUMBER?	( a -- n T | a F )
;	Convert a number string to integer. Push a flag on tos.
	.dw	DECIM-8
	.db 7,"NUMBER?"
NUMBQ:
	INEST

0xc652: 0x12b0 call #0xc098                             cycles: 5
0xc654: 0xc098

	.dw	BASE,AT,TOR,DOLIT,0,OVER,COUNT
	.dw	OVER,CAT,DOLIT,'$',EQUAL,QBRAN,NUMQ1
	.dw	HEX,SWAP,ONEP,SWAP,ONEM
NUMQ1:
	.dw	OVER,CAT,DOLIT,'-',EQUAL,TOR
	.dw	SWAP,RAT,SUBB,SWAP,RAT,PLUS,QDUP
	.dw	QBRAN,NUMQ6
	.dw	ONEM,TOR
NUMQ2:
	.dw	DUPP,TOR,CAT,BASE,AT,DIGTQ
	.dw	QBRAN,NUMQ4
	.dw	SWAP,BASE,AT,STAR,PLUS,RFROM,ONEP
	.dw	DONXT,NUMQ2
	.dw	RAT,SWAP,DROP,QBRAN,NUMQ3
	.dw	NEGAT
NUMQ3:
	.dw	SWAP
	.dw	BRAN,NUMQ5
NUMQ4:
	.dw	RFROM,RFROM,DDROP,DDROP,DOLIT,0
NUMQ5:
	.dw	DUPP
NUMQ6:
	.dw	RFROM,DDROP,RFROM,BASE,STORE,EXIT

;; Terminal output

;   BL	( -- 32 )
;	Return 32, the blank character.
	.dw	NUMBQ-8
	.db 2,"BL",0
BLANK:
	ICONST

0xc6f2: 0x12b0 call #0xc08c                             cycles: 5
0xc6f4: 0xc08c

	.dw	20H

;   SPACE	( -- )
;	Send the blank character to the output device.
	.dw	BLANK-4
	.db 5,"SPACE"
SPACE:
	INEST

0xc700: 0x12b0 call #0xc098                             cycles: 5
0xc702: 0xc098

	.dw	BLANK,EMIT,EXIT

;   SPACES	( +n -- )
;	Send n spaces to the output device.
	.dw	SPACE-6
	.db 6,"SPACES",0
SPACS:
	INEST

0xc714: 0x12b0 call #0xc098                             cycles: 5
0xc716: 0xc098

	.dw	DOLIT,0,MAX,TOR,BRAN,CHAR2
CHAR1:
	.dw	SPACE
CHAR2:
	.dw	DONXT,CHAR1,EXIT

;   TYPE	( b u -- )
;	Output u characters from b.
	.dw	SPACS-8
	.db 4,"TYPE",0
TYPEE:
	INEST

0xc734: 0x12b0 call #0xc098                             cycles: 5
0xc736: 0xc098

	.dw	TOR,BRAN,TYPE2
TYPE1:
	.dw	DUPP,CAT,TCHAR,EMIT
	.dw	ONEP
TYPE2:
	.dw	DONXT,TYPE1
	.dw	DROP,EXIT

;   CR	( -- )
;	Output a carriage return and a line feed.
	.dw	TYPEE-6
	.db 2,"CR",0
CR:
	INEST

0xc756: 0x12b0 call #0xc098                             cycles: 5
0xc758: 0xc098

	.dw	DOLIT,CRR,EMIT
	.dw	DOLIT,LF,EMIT,EXIT

;   do$	( -- a )
;	Return the address of a compiled string.
;	.dw	CR-4
;	.db COMPO+3,"do$"
DOSTR:
	INEST

0xc768: 0x12b0 call #0xc098                             cycles: 5
0xc76a: 0xc098

	.dw	RFROM,RAT,RFROM,COUNT,PLUS
	.dw	ALGND,TOR,SWAP,TOR,EXIT

;   $"|	( -- a )
;	Run time routine compiled by $". Return address of a compiled string.
;	.dw	CR-4
;	.db COMPO+3,"$""|"
STRQP:
	INEST

0xc780: 0x12b0 call #0xc098                             cycles: 5
0xc782: 0xc098

	.dw	DOSTR,EXIT	;force a call to do$

;   ."|	( -- )
;	Run time routine of ." . Output a compiled string.
;	.dw	STRQP-4
;	.db COMPO+3,".""|"
DOTQP:
	INEST

0xc788: 0x12b0 call #0xc098                             cycles: 5
0xc78a: 0xc098

	.dw	DOSTR,COUNT,TYPEE,EXIT

;   .R	( n +n -- )
;	Display an integer in a field of n columns, right justified.
	.dw	CR-4
	.db 2,".R",0
DOTR:
	INEST

0xc79a: 0x12b0 call #0xc098                             cycles: 5
0xc79c: 0xc098

	.dw	TOR,STR,RFROM,OVER,SUBB
	.dw	SPACS,TYPEE,EXIT

;   U.R	( u +n -- )
;	Display an unsigned integer in n column, right justified.
	.dw	DOTR-4
	.db 3,"U.R"
UDOTR:
	INEST

0xc7b4: 0x12b0 call #0xc098                             cycles: 5
0xc7b6: 0xc098

	.dw	TOR,BDIGS,DIGS,EDIGS
	.dw	RFROM,OVER,SUBB,SPACS,TYPEE,EXIT

;   U.	( u -- )
;	Display an unsigned integer in free format.
	.dw	UDOTR-4
	.db 2,"U.",0
UDOT:
	INEST

0xc7d2: 0x12b0 call #0xc098                             cycles: 5
0xc7d4: 0xc098

	.dw	BDIGS,DIGS,EDIGS,SPACE,TYPEE,EXIT

;   .	( w -- )
;	Display an integer in free format, preceeded by a space.
	.dw	UDOT-4
	.db 1,"."
DOT:
	INEST

0xc7e6: 0x12b0 call #0xc098                             cycles: 5
0xc7e8: 0xc098

	.dw	BASE,AT,DOLIT,10,XORR	;?decimal
	.dw	QBRAN,DOT1
	.dw	UDOT,EXIT	;no, display unsigned
DOT1:	.dw	STR,SPACE,TYPEE,EXIT	;yes, display signed

;   ?	( a -- )
;	Display the contents in a memory cell.
	.dw	DOT-2
	.db 1,"?"
QUEST:
	INEST

0xc808: 0x12b0 call #0xc098                             cycles: 5
0xc80a: 0xc098

	.dw	AT,DOT,EXIT

;; Parsing

;   parse	( b u c -- b u delta ; <string> )
;	Scan string delimited by c. Return found string and its offset.
;	.dw	QUEST-2
;	.db 5,"parse"
PARS:
	INEST

0xc812: 0x12b0 call #0xc098                             cycles: 5
0xc814: 0xc098

	.dw	TEMP,STORE,OVER,TOR,DUPP,QBRAN,PARS8
	.dw	ONEM,TEMP,AT,BLANK,EQUAL,QBRAN,PARS3
	.dw	TOR
PARS1:
	.dw	BLANK,OVER,CAT	;skip leading blanks ONLY
	.dw	SUBB,ZLESS,INVER,QBRAN,PARS2
	.dw	ONEP,DONXT,PARS1
	.dw	RFROM,DROP,DOLIT,0,DUPP,EXIT
PARS2:
	.dw	RFROM
PARS3:
	.dw	OVER,SWAP,TOR
PARS4:
	.dw	TEMP,AT,OVER,CAT,SUBB	;scan for delimiter
	.dw	TEMP,AT,BLANK,EQUAL,QBRAN,PARS5
	.dw	ZLESS
PARS5:
	.dw	QBRAN,PARS6
	.dw	ONEP,DONXT,PARS4
	.dw	DUPP,TOR,BRAN,PARS7
PARS6:
	.dw	RFROM,DROP,DUPP,ONEP,TOR
PARS7:
	.dw	OVER,SUBB,RFROM,RFROM,SUBB,EXIT
PARS8:
	.dw	OVER,RFROM,SUBB,EXIT

;   PARSE	( c -- b u ; <string> )
;	Scan input stream and return counted string delimited by c.
;	.dw	QUEST-2
;	.db 5,"PARSE"
PARSE:
	INEST

0xc8a6: 0x12b0 call #0xc098                             cycles: 5
0xc8a8: 0xc098

	.dw	TOR,TIB,INN,AT,PLUS	;current input buffer pointer
	.dw	NTIB,AT,INN,AT,SUBB	;remaining count
	.dw	RFROM,PARS,INN,PSTOR,EXIT

;   .(	( -- )
;	Output following string up to next ) .
	.dw	QUEST-2
	.db IMEDD+2,".(",0
DOTPR:
	INEST

0xc8ce: 0x12b0 call #0xc098                             cycles: 5
0xc8d0: 0xc098

	.dw	DOLIT,")",PARSE,TYPEE,EXIT

;   (	( -- )
;	Ignore following string up to next ) . A comment.
	.dw	DOTPR-4
	.db IMEDD+1,"("
PAREN:
	INEST

0xc8e0: 0x12b0 call #0xc098                             cycles: 5
0xc8e2: 0xc098

	.dw	DOLIT,")",PARSE,DDROP,EXIT

;   \	( -- )
;	Ignore following text till the end of line.
	.dw	PAREN-2
	.db IMEDD+1
    .db 5Ch ; CC: "\" ; naken: [char] \    ;mk
BKSLA:
	INEST

0xc8f2: 0x12b0 call #0xc098                             cycles: 5
0xc8f4: 0xc098

	.dw	NTIB,AT,INN,STORE,EXIT

;   CHAR	( -- c )
;	Parse next word and return its first character.
	.dw	BKSLA-2
	.db 4,"CHAR",0
CHAR:
	INEST

0xc908: 0x12b0 call #0xc098                             cycles: 5
0xc90a: 0xc098

	.dw	BLANK,PARSE,DROP,CAT,EXIT

;   TOKEN	( -- a ; <string> )
;	Parse a word from input stream and copy it to name dictionary.
	.dw	CHAR-6
	.db 5,"TOKEN"
TOKEN:
	INEST

0xc91e: 0x12b0 call #0xc098                             cycles: 5
0xc920: 0xc098

	.dw	BLANK,PARSE,DOLIT,31,MIN
TOKEN1:
	.dw	HERE,DDUP,CSTOR,ONEP
	.dw	SWAP,CMOVE,HERE
	.dw	DOLIT,0,HERE,COUNT,PLUS,CSTOR,EXIT

;   WORD	( c -- a ; <string> )
;	Parse a word from input stream and copy it to code dictionary.
	.dw	TOKEN-6
	.db 4,"WORD",0
WORDD:
	INEST

0xc950: 0x12b0 call #0xc098                             cycles: 5
0xc952: 0xc098

	.dw	PARSE,BRAN,TOKEN1

;; Dictionary search

;   NAME>	( na -- ca )
;	Return a code address given a name address.
;	.dw	WORDD-6
;	.db 5,"NAME>"
NAMET:
	mov.b	@tos+,temp0

0xc95a: 0x4477 mov.b @r4+, r7                           cycles: 2

	and	#0x1F,temp0

0xc95c: 0xf037 and.w #0x001f, r7                        cycles: 2
0xc95e: 0x001f

	add	temp0,tos

0xc960: 0x5704 add.w r7, r4                             cycles: 1

	inc	tos

0xc962: 0x5314 add.w #1, r4                             cycles: 1

	bic	#1,tos

0xc964: 0xc314 bic.w #1, r4                             cycles: 1

	INEXT

0xc966: 0x4630 mov.w @r6+, PC                           cycles: 3


;   SAME?	( a a -- a a f \ -0+ )
;	Compare u cells in two strings. Return 0 if identical.
;	.dw	NAMET-6
;	.db 5,"SAME?"
SAMEQ:
	pushs

0xc968: 0x8325 sub.w #2, r5                             cycles: 1


0xc96a: 0x4485 mov.w r4, 0(r5)                          cycles: 4
0xc96c: 0x0000

	mov	2(stack),tos

0xc96e: 0x4514 mov.w 2(r5), r4                          cycles: 3
0xc970: 0x0002

	mov.b	@tos,tos

0xc972: 0x4464 mov.b @r4, r4                            cycles: 2

SAME1:
	mov	2(stack),temp0

0xc974: 0x4517 mov.w 2(r5), r7                          cycles: 3
0xc976: 0x0002

	add	tos,temp0

0xc978: 0x5407 add.w r4, r7                             cycles: 1

	mov.b	0(temp0),temp0

0xc97a: 0x4757 mov.b 0(r7), r7                          cycles: 3
0xc97c: 0x0000

	mov	0(stack),temp1

0xc97e: 0x4518 mov.w 0(r5), r8                          cycles: 3
0xc980: 0x0000

	add	tos,temp1

0xc982: 0x5408 add.w r4, r8                             cycles: 1

	mov.b	0(temp1),temp1

0xc984: 0x4858 mov.b 0(r8), r8                          cycles: 3
0xc986: 0x0000

	sub	temp1,temp0

0xc988: 0x8807 sub.w r8, r7                             cycles: 1

	jnz	SAME2

0xc98a: 0x2003 jne 0xc992  (offset: 6)                  cycles: 2

	dec	tos

0xc98c: 0x8314 sub.w #1, r4                             cycles: 1

	jnz	SAME1

0xc98e: 0x23f2 jne 0xc974  (offset: -28)                cycles: 2

	INEXT

0xc990: 0x4630 mov.w @r6+, PC                           cycles: 3

SAME2:
	jmp TRUE1

0xc992: 0x3e58 jmp 0xc644  (offset: -848)               cycles: 2


;   NAME?	( a -- ca na | a F )
;	Search all context vocabularies for a string.
;	.dw	WORDD-6
;	.db 5,"NAME?"
NAMEQ:
	INEST

0xc994: 0x12b0 call #0xc098                             cycles: 5
0xc996: 0xc098

	.dw	CNTXT,AT
FIND1:
	.dw	DUPP,QBRAN,FIND3	;end of dictionary
	.dw	OVER,AT,OVER,AT,DOLIT,MASKK,ANDD,EQUAL
	.dw	QBRAN,FIND4
	.dw	SAMEQ,QBRAN,FIND2	;match
FIND4:
	.dw	CELLM,AT,BRAN,FIND1
FIND2:
	.dw	SWAP,DROP,DUPP,NAMET,SWAP,EXIT
FIND3:
	.dw	EXIT

;; Terminal input

;   ^H	( bot eot cur -- bot eot cur )
;	Backup the cursor by one character.
;	.dw	NAMEQ-6
;	.db 2,"^H",0
BKSP:
	INEST

0xc9d2: 0x12b0 call #0xc098                             cycles: 5
0xc9d4: 0xc098

	.dw	TOR,OVER,RFROM,SWAP,OVER,XORR
	.dw	QBRAN,BACK1
	.dw	DOLIT,BKSPP,EMIT,ONEM
	.dw	BLANK,EMIT,DOLIT,BKSPP,EMIT
BACK1:
	.dw	EXIT

;   TAP	( bot eot cur c -- bot eot cur )
;	Accept and echo the key stroke and bump the cursor.
;	.dw	BKSP-4
;	.db 3,"TAP"
TAP:
	INEST

0xc9fa: 0x12b0 call #0xc098                             cycles: 5
0xc9fc: 0xc098

	.dw	DUPP,EMIT,OVER,CSTOR,ONEP,EXIT

;   kTAP	( bot eot cur c -- bot eot cur )
;	Process a key stroke, CR or backspace.
;	.dw	TAP-4
;	.db 4,"kTAP",0
KTAP:
	INEST

0xca0a: 0x12b0 call #0xc098                             cycles: 5
0xca0c: 0xc098

	.dw	DUPP,DOLIT,CRR,XORR,QBRAN,KTAP2
	.dw	DOLIT,BKSPP,XORR,QBRAN,KTAP1
	.dw	BLANK,TAP,EXIT
KTAP1:
	.dw	BKSP,EXIT
KTAP2:
	.dw	DROP,SWAP,DROP,DUPP,EXIT

;   accept	( b u -- b u )
;	Accept characters to input buffer. Return with actual count.
	.dw	WORDD-6
	.db 6,"ACCEPT",0
ACCEP:
	INEST

0xca42: 0x12b0 call #0xc098                             cycles: 5
0xca44: 0xc098

	.dw	OVER,PLUS,OVER
ACCP1:
	.dw	DDUP,XORR,QBRAN,ACCP4
	.dw	KEY,DUPP,BLANK,SUBB,DOLIT,95,ULESS
	.dw	QBRAN,ACCP2
	.dw	TAP,BRAN,ACCP1
ACCP2:
	.dw	KTAP
ACCP3:
	.dw	BRAN,ACCP1
ACCP4:
	.dw	DROP,OVER,SUBB,EXIT

;   QUERY	( -- )
;	Accept input stream to terminal input buffer.
	.dw	ACCEP-8
	.db 5,"QUERY"
QUERY:
	INEST

0xca82: 0x12b0 call #0xc098                             cycles: 5
0xca84: 0xc098

	.dw	TIB,DOLIT,80,ACCEP,NTIB,STORE
	.dw	DROP,DOLIT,0,INN,STORE,EXIT

;; Error handling

; QUIT inits return stack. ERROR inits both stacks.

;   ERROR	( a -- )
;	Return address of a null string with zero count.
;	.dw	QUERY-6
;	.db 5,"ERROR"
ERROR:
	INEST

0xca9e: 0x12b0 call #0xc098                             cycles: 5
0xcaa0: 0xc098

	.dw	SPACE,COUNT,TYPEE,DOLIT
	.dw	3FH,EMIT,CR,SPSTO,QUIT

;   abort"	( f -- )
;	Run time routine of ABORT" . Abort with a message.
;	.dw	ERROR-6
;	.db COMPO+6,"abort""",0
ABORQ:
	INEST

0xcab4: 0x12b0 call #0xc098                             cycles: 5
0xcab6: 0xc098

	.dw	QBRAN,ABOR1	;text flag
	.dw	DOSTR,COUNT,TYPEE,SPSTO,QUIT	;pass error string
ABOR1:
	.dw	DOSTR,DROP,EXIT

;; Text interpreter

;   $INTERPRET	( a -- )
;	Interpret a word. If failed, try to convert it to an integer.
;	.dw	ERROR-6
;	.db 10,"$INTERPRET",0
INTER:
	INEST

0xcacc: 0x12b0 call #0xc098                             cycles: 5
0xcace: 0xc098

	.dw	NAMEQ,QDUP	;?defined
	.dw	QBRAN,INTE1
	.dw	AT,DOLIT,COMPO,ANDD	;?compile only lexicon bits
	.dw	ABORQ
	.db 13," compile only"
	.dw	EXECU,EXIT	;execute defined word
INTE1:
	.dw	NUMBQ	;convert a number
	.dw	QBRAN,INTE2,EXIT
INTE2:
	.dw	ERROR	;error

;   [	( -- )
;	Start the text interpreter.
	.dw	QUERY-6
	.db IMEDD+1,"["
LBRAC:
	INEST

0xcb02: 0x12b0 call #0xc098                             cycles: 5
0xcb04: 0xc098

	.dw	DOLIT,INTER,TEVAL,STORE,EXIT

;   .OK	( -- )
;	Display 'ok' only while interpreting.
;	.dw	LBRAC-2
;	.db 3,".OK"
DOTOK:
	INEST

0xcb10: 0x12b0 call #0xc098                             cycles: 5
0xcb12: 0xc098

	.dw	DOLIT,INTER,TEVAL,AT,EQUAL
	.dw	QBRAN,DOTO1
	.dw	DOTQP
	.db 3," ok"
DOTO1:	.dw	CR,EXIT

;   ?STACK	( -- )
;	Abort if the data stack underflows.
;	.dw	DOTOK-4
;	.db 6,"?STACK",0
QSTAC:
	INEST

0xcb2c: 0x12b0 call #0xc098                             cycles: 5
0xcb2e: 0xc098

	.dw	DEPTH,ZLESS	;check only for underflow
	.dw	ABORQ
	.db 10," underflow",0
	.dw	EXIT

;   EVAL	( -- )
;	Interpret the input stream.
;	.dw	QSTAC-8
;	.db 4,"EVAL",0
EVAL:
	INEST

0xcb44: 0x12b0 call #0xc098                             cycles: 5
0xcb46: 0xc098

EVAL1:
	.dw	TOKEN,DUPP,CAT	;?input stream empty
	.dw	QBRAN,EVAL2
	.dw	TEVAL,ATEXE,QSTAC	;evaluate input, check stack
	.dw	BRAN,EVAL1
EVAL2:
	.dw	DROP,DOTOK,EXIT	;prompt

;   QUIT	( -- )
;	Reset return stack pointer and start text interpreter.
	.dw	LBRAC-2
	.db 4,"QUIT",0
QUIT:
	INEST

0xcb6a: 0x12b0 call #0xc098                             cycles: 5
0xcb6c: 0xc098

	.dw	RPSTO,LBRAC	;start interpretation
QUIT1:
	.dw	QUERY,EVAL	;get input
	.dw	BRAN,QUIT1	;continue till error

;; Compiler utilities

;   ALLOT	( n -- )
;	Allocate n bytes to the RAM dictionary.
	.dw	QUIT-6
	.db 5,"ALLOT"
ALLOT:
	INEST

0xcb82: 0x12b0 call #0xc098                             cycles: 5
0xcb84: 0xc098

	.dw	DP,PSTOR,EXIT	;adjust code pointer

;   IALLOT	( n -- )
;	Allocate n bytes to the code dictionary.
	.dw	ALLOT-6
	.db 6,"IALLOT",0
IALLOT:
	INEST

0xcb96: 0x12b0 call #0xc098                             cycles: 5
0xcb98: 0xc098

	.dw	CP,PSTOR,EXIT	;adjust code pointer

;   I!	( n a -- )
;	Store n to address a in code dictionary.
	.dw	IALLOT-8
	.db 2,"I!",0
ISTORE:
	mov	#FWKEY,&FCTL3 ; Clear LOCK

0xcba6: 0x40b2 mov.w #0xa500, &0x012c                   cycles: 5
0xcba8: 0xa500
0xcbaa: 0x012c

	mov	#FWKEY+WRT,&FCTL1 ; Enable write

0xcbac: 0x40b2 mov.w #0xa540, &0x0128                   cycles: 5
0xcbae: 0xa540
0xcbb0: 0x0128

;	call	#STORE
	mov.w	@stack+,0(tos)

0xcbb2: 0x45b4 mov.w @r5+, 0(r4)                        cycles: 5
0xcbb4: 0x0000

	pops

0xcbb6: 0x4534 mov.w @r5+, r4                           cycles: 2

	mov	#FWKEY,&FCTL1 ; Done. Clear WRT

0xcbb8: 0x40b2 mov.w #0xa500, &0x0128                   cycles: 5
0xcbba: 0xa500
0xcbbc: 0x0128

	mov	#FWKEY+LOCK,&FCTL3 ; Set LOCK

0xcbbe: 0x40b2 mov.w #0xa510, &0x012c                   cycles: 5
0xcbc0: 0xa510
0xcbc2: 0x012c

	INEXT

0xcbc4: 0x4630 mov.w @r6+, PC                           cycles: 3


;   ERASE	( a -- )
;	Erase a segment at address a.
	.dw	ISTORE-4
	.db 5,"ERASE"
IERASE:
	mov	#FWKEY,&FCTL3 ; Clear LOCK

0xcbce: 0x40b2 mov.w #0xa500, &0x012c                   cycles: 5
0xcbd0: 0xa500
0xcbd2: 0x012c

	mov	#FWKEY+ERASE,&FCTL1 ; Enable erase

0xcbd4: 0x40b2 mov.w #0xa502, &0x0128                   cycles: 5
0xcbd6: 0xa502
0xcbd8: 0x0128

	clr	0(tos)

0xcbda: 0x4384 mov.w #0, 0(r4)                          cycles: 4
0xcbdc: 0x0000

	mov	#FWKEY+LOCK,&FCTL3 ; Set LOCK

0xcbde: 0x40b2 mov.w #0xa510, &0x012c                   cycles: 5
0xcbe0: 0xa510
0xcbe2: 0x012c

	pops

0xcbe4: 0x4534 mov.w @r5+, r4                           cycles: 2

	INEXT

0xcbe6: 0x4630 mov.w @r6+, PC                           cycles: 3


;   WRITE	( src dest n -- )
;	Copy n byte from src to dest.  Dest is in flash memory.
	.dw	IERASE-6
	.db 5,"WRITE"
WRITE:
	INEST

0xcbf0: 0x12b0 call #0xc098                             cycles: 5
0xcbf2: 0xc098

	.dw	TWOSL,TOR
WRITE1:
	.dw	OVER,AT,OVER,ISTORE
	.dw	CELLP,SWAP,CELLP,SWAP
	.dw	DONXT,WRITE1
	.dw	DDROP,EXIT

;   ,	( w -- )
;	Compile an integer into the code dictionary.
	.dw	WRITE-6
	.db 1,","
COMMA:
	INEST

0xcc14: 0x12b0 call #0xc098                             cycles: 5
0xcc16: 0xc098

	.dw	CP,AT,DUPP,CELLP	;cell boundary
	.dw	CP,STORE,ISTORE,EXIT

;   call,	( w -- )
;	Compile a call instruction into the code dictionary.
;	.dw	COMMA-2
;	.db 5,"call,"
CALLC:
	INEST

0xcc28: 0x12b0 call #0xc098                             cycles: 5
0xcc2a: 0xc098

	.dw	DOLIT,CALLL,COMMA
	.dw	COMMA,EXIT

;   [COMPILE]	( -- ; <string> )
;	Compile the next immediate word into code dictionary.
;	.dw	COMMA-2
;	.db IMEDD+9,"[COMPILE]"
BCOMP:
	INEST

0xcc36: 0x12b0 call #0xc098                             cycles: 5
0xcc38: 0xc098

	.dw	TICK,COMMA,EXIT

;   COMPILE	( -- )
;	Compile the next address in colon list to code dictionary.
;	.dw	BCOMP-10
;	.db COMPO+7,"COMPILE"
COMPI:
	INEST

0xcc40: 0x12b0 call #0xc098                             cycles: 5
0xcc42: 0xc098

	.dw	RFROM,DUPP,AT,COMMA	;compile address
	.dw	CELLP,TOR,EXIT	;adjust return address

;   LITERAL	( w -- )
;	Compile tos to code dictionary as an integer literal.
;	.dw	COMPI-8
;	.db IMEDD+7,"LITERAL"
LITER:
	INEST

0xcc52: 0x12b0 call #0xc098                             cycles: 5
0xcc54: 0xc098

	.dw	COMPI,DOLIT,COMMA,EXIT

;   $,"	( -- )
;	Compile a literal string up to next " .
;	.dw	LITER-8
;	.db 3,"$,"""
STRCQ:
	INEST

0xcc5e: 0x12b0 call #0xc098                             cycles: 5
0xcc60: 0xc098

	.dw	DOLIT,""""
	.dw	WORDD	;move string to code dictionary
	.dw	STRCQ1,EXIT

STRCQ1:
	INEST

0xcc6c: 0x12b0 call #0xc098                             cycles: 5
0xcc6e: 0xc098

	.dw	DUPP,CAT,TWOSL	;calculate aligned end of string
	.dw	TOR
STRCQ2:
	.dw	DUPP,AT,COMMA,CELLP
	.dw	DONXT,STRCQ2
	.dw	DROP,EXIT

;; Structures

;   FOR	( -- a )
;	Start a FOR-NEXT loop structure in a colon definition.
	.dw	COMMA-2
	.db IMEDD+3,"FOR"
FOR:
	INEST

0xcc8e: 0x12b0 call #0xc098                             cycles: 5
0xcc90: 0xc098

	.dw	COMPI,TOR,BEGIN,EXIT

;   BEGIN	( -- a )
;	Start an infinite or indefinite loop structure.
	.dw	FOR-4
	.db IMEDD+5,"BEGIN"
BEGIN:
	INEST

0xcca2: 0x12b0 call #0xc098                             cycles: 5
0xcca4: 0xc098

	.dw	CP,AT,EXIT

;   NEXT	( a -- )
;	Terminate a FOR-NEXT loop structure.
	.dw	BEGIN-6
	.db IMEDD+4,"NEXT",0
NEXT:
	INEST

0xccb4: 0x12b0 call #0xc098                             cycles: 5
0xccb6: 0xc098

	.dw	COMPI,DONXT,COMMA,EXIT

;   UNTIL	( a -- )
;	Terminate a BEGIN-UNTIL indefinite loop structure.
	.dw	NEXT-6
	.db IMEDD+5,"UNTIL"
UNTIL:
	INEST

0xccc8: 0x12b0 call #0xc098                             cycles: 5
0xccca: 0xc098

	.dw	COMPI,QBRAN,COMMA,EXIT

;   AGAIN	( a -- )
;	Terminate a BEGIN-AGAIN infinite loop structure.
	.dw	UNTIL-6
	.db IMEDD+5,"AGAIN"
AGAIN:
	INEST

0xccdc: 0x12b0 call #0xc098                             cycles: 5
0xccde: 0xc098

	.dw	COMPI,BRAN,COMMA,EXIT

;   IF	( -- A )
;	Begin a conditional branch structure.
	.dw	AGAIN-6
	.db IMEDD+2,"IF",0
IFF:
	INEST

0xccee: 0x12b0 call #0xc098                             cycles: 5
0xccf0: 0xc098

	.dw	COMPI,QBRAN,BEGIN
	.dw	DOLIT,2,IALLOT,EXIT

;   AHEAD	( -- A )
;	Compile a forward branch instruction.
;	.dw	IFF-4
;	.db IMEDD+5,"AHEAD"
AHEAD:
	INEST

0xcd00: 0x12b0 call #0xc098                             cycles: 5
0xcd02: 0xc098

	.dw	COMPI,BRAN,BEGIN
	.dw	DOLIT,2,IALLOT,EXIT

;   REPEAT	( A a -- )
;	Terminate a BEGIN-WHILE-REPEAT indefinite loop.
	.dw	IFF-4
	.db IMEDD+6,"REPEAT",0
REPEA:
	INEST

0xcd1c: 0x12b0 call #0xc098                             cycles: 5
0xcd1e: 0xc098

	.dw	AGAIN,BEGIN,SWAP,ISTORE,EXIT

;   THEN	( A -- )
;	Terminate a conditional branch structure.
	.dw	REPEA-8
	.db IMEDD+4,"THEN",0
THENN:
	INEST

0xcd32: 0x12b0 call #0xc098                             cycles: 5
0xcd34: 0xc098

	.dw	BEGIN,SWAP,ISTORE,EXIT

;   AFT	( a -- a A )
;	Jump to THEN in a FOR-AFT-THEN-NEXT loop the first time through.
	.dw	THENN-6
	.db IMEDD+3,"AFT"
AFT:
	INEST

0xcd44: 0x12b0 call #0xc098                             cycles: 5
0xcd46: 0xc098

	.dw	DROP,AHEAD,BEGIN,SWAP,EXIT

;   ELSE	( A -- A )
;	Start the false clause in an IF-ELSE-THEN structure.
	.dw	AFT-4
	.db IMEDD+4,"ELSE",0
ELSEE:
	INEST

0xcd5a: 0x12b0 call #0xc098                             cycles: 5
0xcd5c: 0xc098

	.dw	AHEAD,SWAP,THENN,EXIT

;   WHILE	( a -- A a )
;	Conditional branch out of a BEGIN-WHILE-REPEAT loop.
	.dw	ELSEE-6
	.db IMEDD+5,"WHILE"
WHILE:
	INEST

0xcd6e: 0x12b0 call #0xc098                             cycles: 5
0xcd70: 0xc098

	.dw	IFF,SWAP,EXIT

;   ABORT"	( -- ; <string> )
;	Conditional abort with an error message.
	.dw	WHILE-6
	.db IMEDD+6,"ABORT",022H,0 ;mk CCS: "ABORT""" ; naken: "ABORT",022H,
ABRTQ:
	INEST

0xcd82: 0x12b0 call #0xc098                             cycles: 5
0xcd84: 0xc098

	.dw	COMPI,ABORQ,STRCQ,EXIT

;   $"	( -- ; <string> )
;	Compile an inline string literal.
	.dw	ABRTQ-8
	.db IMEDD+2,024H,022H,0 ;mk CCS: "$""" ; naken: 024H,022H,
STRQ:
	INEST

0xcd94: 0x12b0 call #0xc098                             cycles: 5
0xcd96: 0xc098

	.dw	COMPI,STRQP,STRCQ,EXIT

;   ."	( -- ; <string> )
;	Compile an inline string literal to be typed out at run time.
	.dw	STRQ-4
	.db IMEDD+2,02EH,022H,0 ;mk CCS: ".""" ; naken: 02EH,022H,
DOTQ:
	INEST

0xcda6: 0x12b0 call #0xc098                             cycles: 5
0xcda8: 0xc098

	.dw	COMPI,DOTQP,STRCQ,EXIT

;; Colon compiler

;   ?UNIQUE	( a -- a )
;	Display a warning message if the word already exists.
;	.dw	DOTQ-4
;	.db 7,"?UNIQUE"
UNIQU:
	INEST

0xcdb2: 0x12b0 call #0xc098                             cycles: 5
0xcdb4: 0xc098

	.dw	DUPP,NAMEQ	;?name exists
	.dw	QBRAN,UNIQ1	;redefinitions are OK
	.dw	DOTQP
	.db 7," reDef "	;but warn the user
	.dw	OVER,COUNT,TYPEE	;just in case its not planned
UNIQ1:
	.dw	DROP,EXIT

;   $,n	( na -- )
;	Build a new dictionary name using the string at na.
;	.dw	UNIQU-8
;	.db 3,"$,n"
SNAME:
	INEST

0xcdd2: 0x12b0 call #0xc098                             cycles: 5
0xcdd4: 0xc098

	.dw	DUPP,CAT	;?null input
	.dw	QBRAN,SNAM1
	.dw	UNIQU	;?redefinition
	.dw	LAST,AT,COMMA	;save na for vocabulary link
	.dw	CP,AT,LAST,STORE
	.dw	STRCQ1,EXIT	;fill name field
SNAM1:
	.dw	STRQP
	.db 5," name"	;null input
	.dw	ERROR

;   $COMPILE	( a -- )
;	Compile next word to code dictionary as a token or literal.
;	.dw	UNIQU-8
;	.db 8,"$COMPILE",0
SCOMP:
	INEST

0xcdfc: 0x12b0 call #0xc098                             cycles: 5
0xcdfe: 0xc098

	.dw	NAMEQ,QDUP	;?defined
	.dw	QBRAN,SCOM2
	.dw	AT,DOLIT,IMEDD,ANDD	;?immediate
	.dw	QBRAN,SCOM1
	.dw	EXECU,EXIT	;its immediate, execute
SCOM1:	.dw	COMMA,EXIT	;its not immediate, compile
SCOM2:	.dw	NUMBQ	;try to convert to number
	.dw	QBRAN,SCOM3
	.dw	LITER,EXIT	;compile number as integer
SCOM3:	.dw	ERROR	;error

;   OVERT	( -- )
;	Link a new word into the current vocabulary.
;	.dw	SCOMP-10
;	.db 5,"OVERT"
OVERT:
	INEST

0xce28: 0x12b0 call #0xc098                             cycles: 5
0xce2a: 0xc098

	.dw	LAST,AT,CNTXT,STORE,EXIT

;   ;	( -- )
;	Terminate a colon definition.
	.dw	DOTQ-4
	.db IMEDD+COMPO+1,";"
SEMIS:
	INEST

0xce3a: 0x12b0 call #0xc098                             cycles: 5
0xce3c: 0xc098

	.dw	COMPI,EXIT,LBRAC,OVERT,EXIT

;   ]	( -- )
;	Start compiling the words in the input stream.
	.dw	SEMIS-2
	.db 1,"]"
RBRAC:
	INEST

0xce4c: 0x12b0 call #0xc098                             cycles: 5
0xce4e: 0xc098

	.dw	DOLIT,SCOMP,TEVAL,STORE,EXIT

;   :	( -- ; <string> )
;	Start a new colon definition using next word as its name.
	.dw	RBRAC-2
	.db 1,":"
COLON:
	INEST

0xce5e: 0x12b0 call #0xc098                             cycles: 5
0xce60: 0xc098

	.dw	TOKEN,SNAME,DOLIT,DOLST
	.dw	CALLC,RBRAC,EXIT

;; Defining words

;   HEADER	( -- ; <string> )
;	Compile a new array entry without allocating code space.
;	.dw	DOCON-6
;	.db 6,"HEADER",0
HEADER:
	INEST

0xce70: 0x12b0 call #0xc098                             cycles: 5
0xce72: 0xc098

	.dw	TOKEN,SNAME,OVERT
	.dw	DOLIT,DOCON,CALLC,EXIT

;   CREATE	( -- ; <string> )
;	Compile a new array entry without allocating code space.
	.dw	COLON-2
	.db 6,"CREATE",0
CREAT:
	INEST

0xce8c: 0x12b0 call #0xc098                             cycles: 5
0xce8e: 0xc098

	.dw	HEADER,DP,AT,COMMA,EXIT

;   CONSTANT	( n -- ; <string> )
;	Compile a new constant.
	.dw	CREAT-8
	.db 8,"CONSTANT",0
CONST:
	INEST

0xcea6: 0x12b0 call #0xc098                             cycles: 5
0xcea8: 0xc098

	.dw	HEADER,COMMA,EXIT

;   VARIABLE	( -- ; <string> )
;	Compile a new variable initialized to 0.
	.dw	CONST-10
	.db 8,"VARIABLE",0
VARIA:
	INEST

0xcebc: 0x12b0 call #0xc098                             cycles: 5
0xcebe: 0xc098

	.dw	CREAT,DOLIT,2,ALLOT,EXIT

;; Tools

;   '	( -- ca )
;	Search context vocabularies for the next word in input stream.
	.dw	VARIA-10
	.db 1,"'"
TICK:
	INEST

0xcece: 0x12b0 call #0xc098                             cycles: 5
0xced0: 0xc098

	.dw	TOKEN,NAMEQ	;?defined
	.dw	QBRAN,TICK1
	.dw	EXIT	;yes, push code address
TICK1:
	.dw	ERROR	;no, error

;   DUMP	( a u -- )
;	Dump u bytes from a, in a formatted manner.
	.dw	TICK-2
	.db 4,"DUMP",0
DUMP:
	INEST

0xcee6: 0x12b0 call #0xc098                             cycles: 5
0xcee8: 0xc098

	.dw	DOLIT,7,TOR	;start count down loop
DUMP1:
	.dw	CR,DUPP,DOLIT,5,UDOTR
	.dw	DOLIT,15,TOR
DUMP2:
	.dw	COUNT,DOLIT,3,UDOTR
	.dw	DONXT,DUMP2	;loop till done
	.dw	SPACE,DUPP,DOLIT,16,SUBB
	.dw	DOLIT,16,TYPEE	;display printable characters
	.dw	DONXT,DUMP1	;loop till done
	.dw	DROP,EXIT

;   .S	( ... -- ... )
;	Display the contents of the data stack.
	.dw	DUMP-6
	.db 2,".S",0
DOTS:
	INEST

0xcf2a: 0x12b0 call #0xc098                             cycles: 5
0xcf2c: 0xc098

	.dw	CR,DEPTH	;stack depth
	.dw	TOR	;start count down loop
	.dw	BRAN,DOTS2	;skip first pass
DOTS1:
	.dw	RAT,PICK,DOT	;index stack, display contents
DOTS2:
	.dw	DONXT,DOTS1	;loop till done
	.dw	DOTQP
	.db 4," <sp",0
	.dw	EXIT

;   >NAME	( ca -- na | F )
;	Convert code address to a name address.
;	.dw	DOTS-4
;	.db 5,">NAME"
TNAME:
	INEST

0xcf4c: 0x12b0 call #0xc098                             cycles: 5
0xcf4e: 0xc098

	.dw	TOR,CNTXT,AT	;vocabulary link
TNAM1:
	.dw	DUPP,QBRAN,TNAM2
	.dw	DUPP,NAMET,RAT,XORR	;compare
	.dw	QBRAN,TNAM2
	.dw	CELLM	;continue with next word
	.dw	AT,BRAN,TNAM1
TNAM2:
	.dw	RFROM,DROP,EXIT

;   .ID	( na -- )
;	Display the name at address.
;	.dw	TNAME-6
;	.db 3,".ID"
DOTID:
	INEST

0xcf76: 0x12b0 call #0xc098                             cycles: 5
0xcf78: 0xc098

	.dw	COUNT,DOLIT,01FH,ANDD	;mask lexicon bits
	.dw	TYPEE,EXIT

;   WORDS	( -- )
;	Display the names in the context vocabulary.
	.dw	DOTS-4
	.db 5,"WORDS"
WORDS:
	INEST

0xcf8e: 0x12b0 call #0xc098                             cycles: 5
0xcf90: 0xc098

	.dw	CR,CNTXT,AT	;only in context
WORS1:
	.dw	QDUP	;?at end of list
	.dw	QBRAN,WORS2
	.dw	DUPP,SPACE,DOTID	;display a name
	.dw	CELLM,AT,BRAN,WORS1
WORS2:
	.dw	EXIT

;; Cold boot

;   HI	( -- )
;	Display the sign-on message of eForth.
	.dw	WORDS-6
	.db 2,"HI",0
HI:
	INEST

0xcfb4: 0x12b0 call #0xc098                             cycles: 5
0xcfb6: 0xc098

	.dw	CR,DOTQP
	.db 12,"430eForth43n",0	;model
	.dw	CR,EXIT

;   APP!	( a -- )	Turnkey
;	HEX : APP! 200 ! 1000 ERASE 200 1000 20 WRITE ;
	.dw	HI-4
	.db 4,"APP!",0
APPST:
	INEST

0xcfd6: 0x12b0 call #0xc098                             cycles: 5
0xcfd8: 0xc098

	.dw	TBOOT,STORE,DOLIT,0x1000,IERASE
	.dw	TBOOT,DOLIT,0x1000,DOLIT,0x20
	.dw	WRITE,EXIT

;   COLD	( -- )
;	The hilevel cold start sequence.
	.dw	APPST-6
	.db 4,"COLD",0
COLD:
	INEST

0xcffa: 0x12b0 call #0xc098                             cycles: 5
0xcffc: 0xc098

	.dw	STOIO
	.dw	DOLIT,UZERO,DOLIT,UPP
	.dw	DOLIT,ULAST-UZERO,CMOVE	;initialize user area
	.dw	TBOOT,ATEXE	;application boot
	.dw	QUIT	;start interpretation

init:                ;mk moved from main near COLD : jmp was out of range.
	mov	#RPP,SP	; set up stack

0xd014: 0x4031 mov.w #0x03f8, SP                        cycles: 2
0xd016: 0x03f8

	mov	#SPP,stack

0xd018: 0x4035 mov.w #0x0378, r5                        cycles: 2
0xd01a: 0x0378

	clr	tos

0xd01c: 0x4304 mov.w #0, r4                             cycles: 1

	mov.w   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

0xd01e: 0x40b2 mov.w #0x5a80, &0x0120                   cycles: 5
0xd020: 0x5a80
0xd022: 0x0120

	bis.b   #041h,&P1DIR	; P1.0/6 output

0xd024: 0xd0f2 bis.b #0x41, &0x0022                     cycles: 5
0xd026: 0x0041
0xd028: 0x0022

	jmp	COLD

0xd02a: 0x3fe7 jmp 0xcffa  (offset: -50)                cycles: 2



CTOP:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;
; COLD start moves the following to user variables.

;	.sect	".infoD"  ; CCS: .sect ; naken: .org   ;mk
    .org 01000H ;mk
;   1000-10FF = 256B information memory   ;mk
;   INFO+000h (INFOD):  RAM save area, user variables ;mk
;   INFO+040h (INFOC):  RAM save area ??? ;mk
;   INFO+080h (INFOB):  user interrupt vectors ??? ;mk
;   INFO+0C0h (INFOA):  configuration data - do not use!! ;mk

UZERO:
	.dw	HI	;200H, boot routine
	.dw	BASEE	;202H, BASE
	.dw	0	;204H, tmp
	.dw	0	;206H, >IN
	.dw	0	;208H, #TIB
	.dw	0	;20AH, HLD
	.dw	INTER	;20CH, 'EVAL
	.dw	COLD-6	;20EH, CONTEXT pointer
	.dw	CTOP+8	;210H, CP; pass ISR
	.dw	DPP	;220H, DP
	.dw	COLD-6	;214H, LAST
ULAST:

;===============================================================
;	.sect   ".reset"	; MSP430 RESET Vector  ;mk

; Interrupt vectors are located in the range FFE0-FFFFh.
;       .org 0FFE0h
intvecs: 
;        DC16 VECAREA+00     ; FFE0 - not used
;        DC16  VECAREA+04     ; FFE2 - not used
;        DC16  VECAREA+08     ; FFE4 - IO port P1
;        DC16  VECAREA+12     ; FFE6 - IO port P2
;        DC16  VECAREA+16     ; FFE8 - not used
;        DC16  VECAREA+20     ; FFEA - ADC10
;        DC16  VECAREA+24     ; FFEC - USCI A0/B0 tx, I2C tx/rx
;        DC16  VECAREA+28     ; FFEE - USCI A0/B0 rx, I2C status
;        DC16  VECAREA+32     ; FFF0 - Timer 0_A3
;        DC16  VECAREA+36     ; FFF2 - Timer 0_A3
;        DC16  VECAREA+40     ; FFF4 - Watchdog
;        DC16  VECAREA+44     ; FFF6 - Comparator A
;        DC16  VECAREA+48     ; FFF8 - Timer 1_A3
;        DC16  VECAREA+52     ; FFFA - Timer 1_A3
;        DC16  VECAREA+56     ; FFFC - NMI, osc.fault, flash violation
         .org 0FFFEh
         DC16  init       ; FFFE - Reset

	.end
data sections:
1000: b4 cf 0a 00 00 00 00 00 00 00 00 00 cc ca f4 cf  ................
1010: 34 d0 20 02 f4 cf                                4. ...
c000: 00 00 04 3f 4b 45 59 00                          ...?KEY.
c020: 02 c0 03 4b 45 59                                ...KEY
c038: 22 c0 04 45 4d 49 54 00                          "..EMIT.
c0a0: 3a c0 04 45 58 49 54 00                          :..EXIT.
c0ac: a2 c0 07 45 58 45 43 55 54 45                    ...EXECUTE
c0bc: ae c0 08 40 45 58 45 43 55 54 45 00              ...@EXECUTE.
c0e6: be c0 01 21                                      ...!
c0f2: e8 c0 01 40                                      ...@
c0fa: f4 c0 02 43 21 00                                ...C!.
c10a: fc c0 02 43 40 00                                ...C@.
c11a: 0c c1 02 52 3e 00                                ...R>.
c12a: 1c c1 02 52 40 00                                ...R@.
c13c: 2c c1 42 3e 52 00                                ,.B>R.
c150: 3e c1 04 44 52 4f 50 00                          >..DROP.
c15c: 52 c1 03 44 55 50                                R..DUP
c16a: 5e c1 04 53 57 41 50 00                          ^..SWAP.
c17c: 6c c1 04 4f 56 45 52 00                          l..OVER.
c190: 7e c1 02 30 3c 00                                ...0<.
c1a2: 92 c1 03 41 4e 44                                ...AND
c1ac: a4 c1 02 4f 52 00                                ...OR.
c1b6: ae c1 03 58 4f 52                                ...XOR
c1c0: b8 c1 03 55 4d 2b                                ...UM+
c1d2: c2 c1 04 3f 44 55 50 00                          ...?DUP.
c1e0: d4 c1 03 52 4f 54                                ...ROT
c1f8: e2 c1 05 32 44 52 4f 50                          ...2DROP
c206: fa c1 04 32 44 55 50 00                          ...2DUP.
c21e: 08 c2 01 2b                                      ...+
c226: 20 c2 02 44 2b 00                                 ..D+.
c238: 28 c2 03 4e 4f 54                                (..NOT
c242: 3a c2 06 4e 45 47 41 54 45 00                    :..NEGATE.
c252: 44 c2 07 44 4e 45 47 41 54 45                    D..DNEGATE
c26a: 54 c2 01 2d                                      T..-
c272: 6c c2 03 41 42 53                                l..ABS
c27e: 74 c2 01 3d                                      t..=
c288: 80 c2 02 55 3c 00                                ...U<.
c296: 8a c2 01 3c                                      ...<
c2a2: 98 c2 01 3e                                      ...>
c2ac: a4 c2 03 4d 41 58                                ...MAX
c2bc: ae c2 03 4d 49 4e                                ...MIN
c2c8: be c2 06 55 4d 2f 4d 4f 44 00                    ...UM/MOD.
c300: ca c2 05 4d 2f 4d 4f 44                          ...M/MOD
c30c: 62 c1 96 c1 62 c1 42 c1 d2 c0 20 c3 4c c2 42 c1  b...b.B... .L.B.
c31c: 5c c2 20 c1 42 c1 62 c1 96 c1 d2 c0 2e c3 30 c1  \. .B.b.......0.
c32c: 22 c2 20 c1 d2 c2 20 c1 d2 c0 3e c3 72 c1 4c c2  ". ... ...>.r.L.
c33c: 72 c1 a8 c0 02 c3 04 2f 4d 4f 44 00              r....../MOD.
c34c: 84 c1 96 c1 72 c1 08 c3 a8 c0 42 c3 03 4d 4f 44  ....r.....B..MOD
c360: 48 c3 58 c1 a8 c0 58 c3 01 2f                    H.X...X../
c36e: 48 c3 72 c1 58 c1 a8 c0 68 c3 03 55 4d 2a        H.r.X...h..UM*
c39c: 78 c3 01 2a                                      x..*
c3a4: 7c c3 58 c1 a8 c0 9e c3 02 4d 2a 00              ..X......M*.
c3b4: 0e c2 bc c1 96 c1 42 c1 78 c2 72 c1 78 c2 7c c3  ......B.x.r.x...
c3c4: 20 c1 d2 c0 cc c3 5c c2 a8 c0 ac c3 05 2a 2f 4d   .....\......*/M
c3d4: 4f 44                                            OD
c3da: 42 c1 b0 c3 20 c1 08 c3 a8 c0 d0 c3 02 2a 2f 00  B... ........*/.
c3ee: d6 c3 72 c1 58 c1 a8 c0                          ..r.X...
c406: e6 c3 02 32 2a 00                                ...2*.
c410: 08 c4 02 32 2f 00                                ...2/.
c424: f2 c6 b2 c2 82 c0 7e 00 c2 c2 a8 c0 12 c4 05 44  ...............D
c434: 45 50 54 48                                      EPTH
c44a: 32 c4 04 50 49 43 4b 00                          2..PICK.
c45a: 4c c4 02 2b 21 00                                L..+!.
c468: 5c c4 05 43 4f 55 4e 54                          \..COUNT
c47c: 6a c4 05 43 4d 4f 56 45                          j..CMOVE
c498: 7e c4 04 46 49 4c 4c 00                          ...FILL.
c4b4: 9a c4 05 27 42 4f 4f 54                          ...'BOOT
c4c0: 00 02 b6 c4 04 42 41 53 45 00                    .....BASE.
c4ce: 02 02                                            ..
c4d4: 04 02                                            ..
c4da: 06 02                                            ..
c4e0: 08 02                                            ..
c4e6: 0a 02                                            ..
c4ec: 0c 02                                            ..
c4f2: 0e 02 c4 c4 02 43 50 00                          .....CP.
c4fe: 10 02 f6 c4 02 44 50 00                          .....DP.
c50a: 12 02                                            ..
c510: 14 02 02 c5 04 48 45 52 45 00                    .....HERE.
c51e: 06 c5 f6 c0 a8 c0 14 c5 03 50 41 44              .........PAD
c52e: 1a c5 82 c0 50 00 22 c2 a8 c0 26 c5 03 54 49 42  ....P."...&..TIB
c542: 80 03                                            ..
c558: 82 c0 00 00 72 c1 d2 c2 72 c1 44 c5 a8 c0 3a c5  ....r...r.D...:.
c568: 02 3c 23 00                                      .<#.
c570: 2a c5 e2 c4 ea c0 a8 c0 68 c5 04 48 4f 4c 44 00  *.......h..HOLD.
c584: e2 c4 f6 c0 fa c3 62 c1 e2 c4 ea c0 00 c1 a8 c0  ......b.........
c594: 7a c5 01 23                                      ...#
c59c: ca c4 f6 c0 54 c5 80 c5 a8 c0 96 c5 02 23 53 00  ....T........#S.
c5b0: 98 c5 62 c1 d2 c0 bc c5 ce c0 b0 c5 a8 c0 a8 c5  ..b.............
c5c0: 04 53 49 47 4e 00                                .SIGN.
c5ca: 96 c1 d2 c0 d6 c5 82 c0 2d 00 80 c5 a8 c0 c0 c5  ........-.......
c5da: 02 23 3e 00                                      .#>.
c5e2: 58 c1 e2 c4 f6 c0 2a c5 84 c1 6e c2 a8 c0        X.....*...n...
c5f4: 62 c1 42 c1 78 c2 6c c5 ac c5 20 c1 c6 c5 de c5  b.B.x.l... .....
c604: a8 c0 da c5 03 48 45 58                          .....HEX
c614: 08 c6 07 44 45 43 49 4d 41 4c                    ...DECIMAL
c648: 16 c6 07 4e 55 4d 42 45 52 3f                    ...NUMBER?
c656: ca c4 f6 c0 42 c1 82 c0 00 00 84 c1 70 c4 84 c1  ....B.......p...
c666: 10 c1 82 c0 24 00 82 c2 d2 c0 7c c6 0c c6 72 c1  ....$.........r.
c676: f6 c3 72 c1 fa c3 84 c1 10 c1 82 c0 2d 00 82 c2  ..r.........-...
c686: 42 c1 72 c1 30 c1 6e c2 72 c1 30 c1 22 c2 da c1  B.r.0.n.r.0."...
c696: d2 c0 e0 c6 fa c3 42 c1 62 c1 42 c1 10 c1 ca c4  ......B.b.B.....
c6a6: f6 c0 26 c6 d2 c0 d2 c6 72 c1 ca c4 f6 c0 a0 c3  ..&.....r.......
c6b6: 22 c2 20 c1 f6 c3 da c0 9e c6 30 c1 72 c1 58 c1  ". .......0.r.X.
c6c6: d2 c0 cc c6 4c c2 72 c1 ce c0 de c6 20 c1 20 c1  ....L.r..... . .
c6d6: 00 c2 00 c2 82 c0 00 00 62 c1 20 c1 00 c2 20 c1  ........b. ... .
c6e6: ca c4 ea c0 a8 c0 4a c6 02 42 4c 00              ......J..BL.
c6f6: 20 00 ee c6 05 53 50 41 43 45                     ....SPACE
c704: f2 c6 40 c0 a8 c0 fa c6 06 53 50 41 43 45 53 00  ..@......SPACES.
c718: 82 c0 00 00 b2 c2 42 c1 ce c0 26 c7 00 c7 da c0  ......B...&.....
c728: 24 c7 a8 c0 0c c7 04 54 59 50 45 00              $......TYPE.
c738: 42 c1 ce c0 48 c7 62 c1 10 c1 20 c4 40 c0 f6 c3  B...H.b... .@...
c748: da c0 3e c7 58 c1 a8 c0 2e c7 02 43 52 00        ..>.X......CR.
c75a: 82 c0 0d 00 40 c0 82 c0 0a 00 40 c0 a8 c0        ....@.....@...
c76c: 20 c1 30 c1 20 c1 70 c4 22 c2 1a c4 42 c1 72 c1   .0. .p."...B.r.
c77c: 42 c1 a8 c0                                      B...
c784: 68 c7 a8 c0                                      h...
c78c: 68 c7 70 c4 34 c7 a8 c0 52 c7 02 2e 52 00        h.p.4...R...R.
c79e: 42 c1 f0 c5 20 c1 84 c1 6e c2 14 c7 34 c7 a8 c0  B... ...n...4...
c7ae: 96 c7 03 55 2e 52                                ...U.R
c7b8: 42 c1 6c c5 ac c5 de c5 20 c1 84 c1 6e c2 14 c7  B.l..... ...n...
c7c8: 34 c7 a8 c0 b0 c7 02 55 2e 00                    4......U..
c7d6: 6c c5 ac c5 de c5 00 c7 34 c7 a8 c0 ce c7 01 2e  l.......4.......
c7ea: ca c4 f6 c0 82 c0 0a 00 bc c1 d2 c0 fc c7 d2 c7  ................
c7fa: a8 c0 f0 c5 00 c7 34 c7 a8 c0 e4 c7 01 3f        ......4......?
c80c: f6 c0 e6 c7 a8 c0                                ......
c816: d0 c4 ea c0 84 c1 42 c1 62 c1 d2 c0 9e c8 fa c3  ......B.b.......
c826: d0 c4 f6 c0 f2 c6 82 c2 d2 c0 58 c8 42 c1 f2 c6  ..........X.B...
c836: 84 c1 10 c1 6e c2 96 c1 3e c2 d2 c0 56 c8 f6 c3  ....n...>...V...
c846: da c0 34 c8 20 c1 58 c1 82 c0 00 00 62 c1 a8 c0  ..4. .X.....b...
c856: 20 c1 84 c1 72 c1 42 c1 d0 c4 f6 c0 84 c1 10 c1   ...r.B.........
c866: 6e c2 d0 c4 f6 c0 f2 c6 82 c2 d2 c0 76 c8 96 c1  n...........v...
c876: d2 c0 88 c8 f6 c3 da c0 5e c8 62 c1 42 c1 ce c0  ........^.b.B...
c886: 92 c8 20 c1 58 c1 62 c1 f6 c3 42 c1 84 c1 6e c2  .. .X.b...B...n.
c896: 20 c1 20 c1 6e c2 a8 c0 84 c1 20 c1 6e c2 a8 c0   . .n..... .n...
c8aa: 42 c1 3e c5 dc c4 f6 c0 22 c2 d6 c4 f6 c0 dc c4  B.>.....".......
c8ba: f6 c0 6e c2 20 c1 12 c8 dc c4 60 c4 a8 c0 06 c8  ..n. .....`.....
c8ca: 82 2e 28 00                                      ..(.
c8d2: 82 c0 29 00 a6 c8 34 c7 a8 c0 ca c8 81 28        ..)...4......(
c8e4: 82 c0 29 00 a6 c8 00 c2 a8 c0 de c8 81 5c        ..)..........\
c8f6: d6 c4 f6 c0 dc c4 ea c0 a8 c0 f0 c8 04 43 48 41  .............CHA
c906: 52 00                                            R.
c90c: f2 c6 a6 c8 58 c1 10 c1 a8 c0 02 c9 05 54 4f 4b  ....X........TOK
c91c: 45 4e                                            EN
c922: f2 c6 a6 c8 82 c0 1f 00 c2 c2 1a c5 0e c2 00 c1  ................
c932: f6 c3 72 c1 84 c4 1a c5 82 c0 00 00 1a c5 70 c4  ..r...........p.
c942: 22 c2 00 c1 a8 c0 18 c9 04 57 4f 52 44 00        "........WORD.
c954: a6 c8 ce c0 2c c9                                ....,.
c998: ee c4 f6 c0 62 c1 d2 c0 d0 c9 84 c1 f6 c0 84 c1  ....b...........
c9a8: f6 c0 82 c0 1f 7f a8 c1 82 c2 d2 c0 bc c9 68 c9  ..............h.
c9b8: d2 c0 c4 c9 02 c4 f6 c0 ce c0 9c c9 72 c1 58 c1  ............r.X.
c9c8: 62 c1 5a c9 72 c1 a8 c0 a8 c0                    b.Z.r.....
c9d6: 42 c1 84 c1 20 c1 72 c1 84 c1 bc c1 d2 c0 f8 c9  B... .r.........
c9e6: 82 c0 08 00 40 c0 fa c3 f2 c6 40 c0 82 c0 08 00  ....@.....@.....
c9f6: 40 c0 a8 c0                                      @...
c9fe: 62 c1 40 c0 84 c1 00 c1 f6 c3 a8 c0              b.@.........
ca0e: 62 c1 82 c0 0d 00 bc c1 d2 c0 2e ca 82 c0 08 00  b...............
ca1e: bc c1 d2 c0 2a ca f2 c6 fa c9 a8 c0 d2 c9 a8 c0  ....*...........
ca2e: 58 c1 72 c1 58 c1 62 c1 a8 c0 4a c9 06 41 43 43  X.r.X.b...J..ACC
ca3e: 45 50 54 00                                      EPT.
ca46: 84 c1 22 c2 84 c1 0e c2 bc c1 d2 c0 72 ca 26 c0  ..".........r.&.
ca56: 62 c1 f2 c6 6e c2 82 c0 5f 00 8e c2 d2 c0 6c ca  b...n..._.....l.
ca66: fa c9 ce c0 4c ca 0a ca ce c0 4c ca 58 c1 84 c1  ....L.....L.X...
ca76: 6e c2 a8 c0 3a ca 05 51 55 45 52 59              n...:..QUERY
ca86: 3e c5 82 c0 50 00 42 ca d6 c4 ea c0 58 c1 82 c0  >...P.B.....X...
ca96: 00 00 dc c4 ea c0 a8 c0                          ........
caa2: 00 c7 70 c4 34 c7 82 c0 3f 00 40 c0 56 c7 48 c1  ..p.4...?.@.V.H.
cab2: 6a cb                                            j.
cab8: d2 c0 c6 ca 68 c7 70 c4 34 c7 48 c1 6a cb 68 c7  ....h.p.4.H.j.h.
cac8: 58 c1 a8 c0                                      X...
cad0: 94 c9 da c1 d2 c0 f4 ca f6 c0 82 c0 40 00 a8 c1  ............@...
cae0: b4 ca 0d 20 63 6f 6d 70 69 6c 65 20 6f 6e 6c 79  ... compile onl.
caf0: b6 c0 a8 c0 52 c6 d2 c0 fc ca a8 c0 9e ca 7c ca  ....R...........
cb00: 81 5b                                            .[
cb06: 82 c0 cc ca e8 c4 ea c0 a8 c0                    ..........
cb14: 82 c0 cc ca e8 c4 f6 c0 82 c2 d2 c0 28 cb 88 c7  ............(...
cb24: 03 20 6f 6b 56 c7 a8 c0                          . okV...
cb30: 38 c4 96 c1 b4 ca 0a 20 75 6e 64 65 72 66 6c 6f  8...... underflo
cb40: 77 00 a8 c0                                      w...
cb48: 1e c9 62 c1 10 c1 d2 c0 5c cb e8 c4 c8 c0 2c cb  ..b.....\.....,.
cb58: ce c0 48 cb 58 c1 10 cb a8 c0 00 cb 04 51 55 49  ..H.X........QUI
cb68: 54 00                                            T.
cb6e: 14 c1 02 cb 82 ca 44 cb ce c0 72 cb 64 cb 05 41  ......D...r.d..A
cb7e: 4c 4c 4f 54                                      LLOT
cb86: 06 c5 60 c4 a8 c0 7c cb 06 49 41 4c 4c 4f 54 00  ..`......IALLOT.
cb9a: fa c4 60 c4 a8 c0 8e cb 02 49 21 00              ..`......I!.
cbc6: a2 cb 05 45 52 41 53 45                          ...ERASE
cbe8: c8 cb 05 57 52 49 54 45                          ...WRITE
cbf4: 16 c4 42 c1 84 c1 f6 c0 84 c1 a6 cb fe c3 72 c1  ..B...........r.
cc04: fe c3 72 c1 da c0 f8 cb 00 c2 a8 c0 ea cb 01 2c  ..r............,
cc18: fa c4 f6 c0 62 c1 fe c3 fa c4 ea c0 a6 cb a8 c0  ....b...........
cc2c: 82 c0 b0 12 14 cc 14 cc a8 c0                    ..........
cc3a: ce ce 14 cc a8 c0                                ......
cc44: 20 c1 62 c1 f6 c0 14 cc fe c3 42 c1 a8 c0         .b.......B...
cc56: 40 cc 82 c0 14 cc a8 c0                          @.......
cc62: 82 c0 00 00 50 c9 6c cc a8 c0                    ....P.l...
cc70: 62 c1 10 c1 16 c4 42 c1 62 c1 f6 c0 14 cc fe c3  b.....B.b.......
cc80: da c0 78 cc 58 c1 a8 c0 12 cc 83 46 4f 52        ..x.X......FOR
cc92: 40 cc 42 c1 a2 cc a8 c0 8a cc 85 42 45 47 49 4e  @.B........BEGIN
cca6: fa c4 f6 c0 a8 c0 9c cc 84 4e 45 58 54 00        .........NEXT.
ccb8: 40 cc da c0 14 cc a8 c0 ae cc 85 55 4e 54 49 4c  @..........UNTIL
cccc: 40 cc d2 c0 14 cc a8 c0 c2 cc 85 41 47 41 49 4e  @..........AGAIN
cce0: 40 cc ce c0 14 cc a8 c0 d6 cc 82 49 46 00        @..........IF.
ccf2: 40 cc d2 c0 a2 cc 82 c0 02 00 96 cb a8 c0        @.............
cd04: 40 cc ce c0 a2 cc 82 c0 02 00 96 cb a8 c0 ea cc  @...............
cd14: 86 52 45 50 45 41 54 00                          .REPEAT.
cd20: dc cc a2 cc 72 c1 a6 cb a8 c0 14 cd 84 54 48 45  ....r........THE
cd30: 4e 00                                            N.
cd36: a2 cc 72 c1 a6 cb a8 c0 2c cd 83 41 46 54        ..r.....,..AFT
cd48: 58 c1 00 cd a2 cc 72 c1 a8 c0 40 cd 84 45 4c 53  X.....r...@..ELS
cd58: 45 00                                            E.
cd5e: 00 cd 72 c1 32 cd a8 c0 54 cd 85 57 48 49 4c 45  ..r.2...T..WHILE
cd72: ee cc 72 c1 a8 c0 68 cd 86 41 42 4f 52 54 22 00  ..r...h..ABORT".
cd86: 40 cc b4 ca 5e cc a8 c0 7a cd 82 24 22 00        @...^......$".
cd98: 40 cc 80 c7 5e cc a8 c0 90 cd 82 2e 22 00        @...^.......".
cdaa: 40 cc 88 c7 5e cc a8 c0                          @...^...
cdb6: 62 c1 94 c9 d2 c0 ce cd 88 c7 07 20 72 65 44 65  b.......... reDe
cdc6: 66 20 84 c1 70 c4 34 c7 58 c1 a8 c0              f ..p.4.X...
cdd6: 62 c1 10 c1 d2 c0 f2 cd b2 cd 0c c5 f6 c0 14 cc  b...............
cde6: fa c4 f6 c0 0c c5 ea c0 6c cc a8 c0 80 c7 05 20  ........l...... 
cdf6: 6e 61 6d 65 9e ca                                name..
ce00: 94 c9 da c1 d2 c0 1c ce f6 c0 82 c0 80 00 a8 c1  ................
ce10: d2 c0 18 ce b6 c0 a8 c0 14 cc a8 c0 52 c6 d2 c0  ............R...
ce20: 26 ce 52 cc a8 c0 9e ca                          &.R.....
ce2c: 0c c5 f6 c0 ee c4 ea c0 a8 c0 a2 cd c1 3b        .............;
ce3e: 40 cc a8 c0 02 cb 28 ce a8 c0 38 ce 01 5d        @.....(...8..]
ce50: 82 c0 fc cd e8 c4 ea c0 a8 c0 4a ce 01 3a        ..........J..:
ce62: 1e c9 d2 cd 82 c0 98 c0 28 cc 4c ce a8 c0        ........(.L...
ce74: 1e c9 d2 cd 28 ce 82 c0 8c c0 28 cc a8 c0 5c ce  ....(.....(...\.
ce84: 06 43 52 45 41 54 45 00                          .CREATE.
ce90: 70 ce 06 c5 f6 c0 14 cc a8 c0 84 ce 08 43 4f 4e  p............CON
cea0: 53 54 41 4e 54 00                                STANT.
ceaa: 70 ce 14 cc a8 c0 9c ce 08 56 41 52 49 41 42 4c  p........VARIABL
ceba: 45 00                                            E.
cec0: 8c ce 82 c0 02 00 82 cb a8 c0 b2 ce 01 27        .............'
ced2: 1e c9 94 c9 d2 c0 dc ce a8 c0 9e ca cc ce 04 44  ...............D
cee2: 55 4d 50 00                                      UMP.
ceea: 82 c0 07 00 42 c1 56 c7 62 c1 82 c0 05 00 b4 c7  ....B.V.b.......
cefa: 82 c0 0f 00 42 c1 70 c4 82 c0 03 00 b4 c7 da c0  ....B.p.........
cf0a: 00 cf 00 c7 62 c1 82 c0 10 00 6e c2 82 c0 10 00  ....b.....n.....
cf1a: 34 c7 da c0 f0 ce 58 c1 a8 c0 e0 ce 02 2e 53 00  4.....X.......S.
cf2e: 56 c7 38 c4 42 c1 ce c0 3e cf 30 c1 52 c4 e6 c7  V.8.B...>.0.R...
cf3e: da c0 38 cf 88 c7 04 20 3c 73 70 00 a8 c0        ..8.... <sp...
cf50: 42 c1 ee c4 f6 c0 62 c1 d2 c0 70 cf 62 c1 5a c9  B.....b...p.b.Z.
cf60: 30 c1 bc c1 d2 c0 70 cf 02 c4 f6 c0 ce c0 56 cf  0.....p.......V.
cf70: 20 c1 58 c1 a8 c0                                 .X...
cf7a: 70 c4 82 c0 1f 00 a8 c1 34 c7 a8 c0 26 cf 05 57  p.......4...&..W
cf8a: 4f 52 44 53                                      ORDS
cf92: 56 c7 ee c4 f6 c0 da c1 d2 c0 ac cf 62 c1 00 c7  V...........b...
cfa2: 76 cf 02 c4 f6 c0 ce c0 98 cf a8 c0 88 cf 02 48  v..............H
cfb2: 49 00                                            I.
cfb8: 56 c7 88 c7 0c 34 33 30 65 46 6f 72 74 68 34 33  V....430eForth43
cfc8: 6e 00 56 c7 a8 c0 b0 cf 04 41 50 50 21 00        n.V......APP!.
cfda: bc c4 ea c0 82 c0 00 10 ce cb bc c4 82 c0 00 10  ................
cfea: 82 c0 20 00 f0 cb a8 c0 d0 cf 04 43 4f 4c 44 00  .. ........COLD.
cffe: 4e c0 82 c0 00 10 82 c0 00 02 82 c0 16 00 84 c4  N...............
d00e: bc c4 c8 c0 6a cb                                ....j.
fffe: 14 d0                                            ..


Program Info:
                         LABEL ADDRESS  SCOPE
                          main 0000c000 0
                          QKEY 0000c008 0
                         QKEY1 0000c00e 0
                           KEY 0000c026 0
                          KEY1 0000c02c 0
                          EMIT 0000c040 0
                         EMIT1 0000c040 0
                         STOIO 0000c04e 0
                         DOLIT 0000c082 0
                         DOCON 0000c08c 0
                         DOLST 0000c098 0
                          EXIT 0000c0a8 0
                         EXECU 0000c0b6 0
                         ATEXE 0000c0c8 0
                          BRAN 0000c0ce 0
                         QBRAN 0000c0d2 0
                         DONXT 0000c0da 0
                          SKIP 0000c0e2 0
                         STORE 0000c0ea 0
                            AT 0000c0f6 0
                         CSTOR 0000c100 0
                           CAT 0000c110 0
                         RPSTO 0000c114 0
                         RFROM 0000c120 0
                           RAT 0000c130 0
                           TOR 0000c142 0
                         SPSTO 0000c148 0
                          DROP 0000c158 0
                          DUPP 0000c162 0
                          SWAP 0000c172 0
                          OVER 0000c184 0
                         ZLESS 0000c196 0
                         FALSE 0000c19a 0
                          TRUE 0000c19e 0
                          ANDD 0000c1a8 0
                           ORR 0000c1b2 0
                          XORR 0000c1bc 0
                         UPLUS 0000c1c6 0
                          QDUP 0000c1da 0
                           ROT 0000c1e6 0
                         DDROP 0000c200 0
                          DDUP 0000c20e 0
                          PLUS 0000c222 0
                         DPLUS 0000c22c 0
                         INVER 0000c23e 0
                         NEGAT 0000c24c 0
                         DNEGA 0000c25c 0
                          SUBB 0000c26e 0
                          ABSS 0000c278 0
                         EQUAL 0000c282 0
                         ULESS 0000c28e 0
                          LESS 0000c29a 0
                         GREAT 0000c2a6 0
                           MAX 0000c2b2 0
                          MAX1 0000c2b6 0
                           MIN 0000c2c2 0
                         UMMOD 0000c2d2 0
                        UMMOD2 0000c2da 0
                        UMMOD3 0000c2e4 0
                        UMMOD4 0000c2e6 0
                         MSMOD 0000c308 0
                         MMOD1 0000c320 0
                         MMOD2 0000c32e 0
                         MMOD3 0000c33e 0
                         SLMOD 0000c348 0
                          MODD 0000c35c 0
                         SLASH 0000c36a 0
                         UMSTA 0000c37c 0
                        UMSTA2 0000c382 0
                        UMSTA3 0000c38c 0
                        UMSTA4 0000c38e 0
                          STAR 0000c3a0 0
                         MSTAR 0000c3b0 0
                         MSTA1 0000c3cc 0
                         SSMOD 0000c3d6 0
                         STASL 0000c3ea 0
                          ONEP 0000c3f6 0
                          ONEM 0000c3fa 0
                         CELLP 0000c3fe 0
                         CELLM 0000c402 0
                         CELLS 0000c40c 0
                         TWOSL 0000c416 0
                         ALGND 0000c41a 0
                         TCHAR 0000c420 0
                         DEPTH 0000c438 0
                          PICK 0000c452 0
                         PSTOR 0000c460 0
                         COUNT 0000c470 0
                         CMOVE 0000c484 0
                        CMOVE1 0000c48a 0
                        CMOVE2 0000c490 0
                        CMOVE3 0000c496 0
                          FILL 0000c4a0 0
                          FIL1 0000c4a6 0
                          FIL2 0000c4ac 0
                          FIL3 0000c4b2 0
                         TBOOT 0000c4bc 0
                          BASE 0000c4ca 0
                          TEMP 0000c4d0 0
                          NTIB 0000c4d6 0
                           INN 0000c4dc 0
                           HLD 0000c4e2 0
                         TEVAL 0000c4e8 0
                         CNTXT 0000c4ee 0
                            CP 0000c4fa 0
                            DP 0000c506 0
                          LAST 0000c50c 0
                          HERE 0000c51a 0
                           PAD 0000c52a 0
                           TIB 0000c53e 0
                         DIGIT 0000c544 0
                        DIGIT1 0000c54e 0
                         EXTRC 0000c554 0
                         BDIGS 0000c56c 0
                          HOLD 0000c580 0
                           DIG 0000c598 0
                          DIGS 0000c5ac 0
                         DIGS1 0000c5b0 0
                         DIGS2 0000c5bc 0
                          SIGN 0000c5c6 0
                         SIGN1 0000c5d6 0
                         EDIGS 0000c5de 0
                           STR 0000c5f0 0
                           HEX 0000c60c 0
                         DECIM 0000c61e 0
                         DIGTQ 0000c626 0
                        DIGTQ1 0000c638 0
                        FALSE1 0000c640 0
                         TRUE1 0000c644 0
                         NUMBQ 0000c652 0
                         NUMQ1 0000c67c 0
                         NUMQ2 0000c69e 0
                         NUMQ3 0000c6cc 0
                         NUMQ4 0000c6d2 0
                         NUMQ5 0000c6de 0
                         NUMQ6 0000c6e0 0
                         BLANK 0000c6f2 0
                         SPACE 0000c700 0
                         SPACS 0000c714 0
                         CHAR1 0000c724 0
                         CHAR2 0000c726 0
                         TYPEE 0000c734 0
                         TYPE1 0000c73e 0
                         TYPE2 0000c748 0
                            CR 0000c756 0
                         DOSTR 0000c768 0
                         STRQP 0000c780 0
                         DOTQP 0000c788 0
                          DOTR 0000c79a 0
                         UDOTR 0000c7b4 0
                          UDOT 0000c7d2 0
                           DOT 0000c7e6 0
                          DOT1 0000c7fc 0
                         QUEST 0000c808 0
                          PARS 0000c812 0
                         PARS1 0000c834 0
                         PARS2 0000c856 0
                         PARS3 0000c858 0
                         PARS4 0000c85e 0
                         PARS5 0000c876 0
                         PARS6 0000c888 0
                         PARS7 0000c892 0
                         PARS8 0000c89e 0
                         PARSE 0000c8a6 0
                         DOTPR 0000c8ce 0
                         PAREN 0000c8e0 0
                         BKSLA 0000c8f2 0
                          CHAR 0000c908 0
                         TOKEN 0000c91e 0
                        TOKEN1 0000c92c 0
                         WORDD 0000c950 0
                         NAMET 0000c95a 0
                         SAMEQ 0000c968 0
                         SAME1 0000c974 0
                         SAME2 0000c992 0
                         NAMEQ 0000c994 0
                         FIND1 0000c99c 0
                         FIND4 0000c9bc 0
                         FIND2 0000c9c4 0
                         FIND3 0000c9d0 0
                          BKSP 0000c9d2 0
                         BACK1 0000c9f8 0
                           TAP 0000c9fa 0
                          KTAP 0000ca0a 0
                         KTAP1 0000ca2a 0
                         KTAP2 0000ca2e 0
                         ACCEP 0000ca42 0
                         ACCP1 0000ca4c 0
                         ACCP2 0000ca6c 0
                         ACCP3 0000ca6e 0
                         ACCP4 0000ca72 0
                         QUERY 0000ca82 0
                         ERROR 0000ca9e 0
                         ABORQ 0000cab4 0
                         ABOR1 0000cac6 0
                         INTER 0000cacc 0
                         INTE1 0000caf4 0
                         INTE2 0000cafc 0
                         LBRAC 0000cb02 0
                         DOTOK 0000cb10 0
                         DOTO1 0000cb28 0
                         QSTAC 0000cb2c 0
                          EVAL 0000cb44 0
                         EVAL1 0000cb48 0
                         EVAL2 0000cb5c 0
                          QUIT 0000cb6a 0
                         QUIT1 0000cb72 0
                         ALLOT 0000cb82 0
                        IALLOT 0000cb96 0
                        ISTORE 0000cba6 0
                        IERASE 0000cbce 0
                         WRITE 0000cbf0 0
                        WRITE1 0000cbf8 0
                         COMMA 0000cc14 0
                         CALLC 0000cc28 0
                         BCOMP 0000cc36 0
                         COMPI 0000cc40 0
                         LITER 0000cc52 0
                         STRCQ 0000cc5e 0
                        STRCQ1 0000cc6c 0
                        STRCQ2 0000cc78 0
                           FOR 0000cc8e 0
                         BEGIN 0000cca2 0
                          NEXT 0000ccb4 0
                         UNTIL 0000ccc8 0
                         AGAIN 0000ccdc 0
                           IFF 0000ccee 0
                         AHEAD 0000cd00 0
                         REPEA 0000cd1c 0
                         THENN 0000cd32 0
                           AFT 0000cd44 0
                         ELSEE 0000cd5a 0
                         WHILE 0000cd6e 0
                         ABRTQ 0000cd82 0
                          STRQ 0000cd94 0
                          DOTQ 0000cda6 0
                         UNIQU 0000cdb2 0
                         UNIQ1 0000cdce 0
                         SNAME 0000cdd2 0
                         SNAM1 0000cdf2 0
                         SCOMP 0000cdfc 0
                         SCOM1 0000ce18 0
                         SCOM2 0000ce1c 0
                         SCOM3 0000ce26 0
                         OVERT 0000ce28 0
                         SEMIS 0000ce3a 0
                         RBRAC 0000ce4c 0
                         COLON 0000ce5e 0
                        HEADER 0000ce70 0
                         CREAT 0000ce8c 0
                         CONST 0000cea6 0
                         VARIA 0000cebc 0
                          TICK 0000cece 0
                         TICK1 0000cedc 0
                          DUMP 0000cee6 0
                         DUMP1 0000cef0 0
                         DUMP2 0000cf00 0
                          DOTS 0000cf2a 0
                         DOTS1 0000cf38 0
                         DOTS2 0000cf3e 0
                         TNAME 0000cf4c 0
                         TNAM1 0000cf56 0
                         TNAM2 0000cf70 0
                         DOTID 0000cf76 0
                         WORDS 0000cf8e 0
                         WORS1 0000cf98 0
                         WORS2 0000cfac 0
                            HI 0000cfb4 0
                         APPST 0000cfd6 0
                          COLD 0000cffa 0
                          init 0000d014 0
                          CTOP 0000d02c 0
                         UZERO 00001000 0
                         ULAST 00001016 0
                       intvecs 00001016 0
 -> Total symbols: 275

Include Paths: .
               /usr/local/share/naken_asm/include
               include
 Instructions: 436
   Code Bytes: 1304
   Data Bytes: 2860
  Low Address: 1000 (4096)
 High Address: ffff (65535)

